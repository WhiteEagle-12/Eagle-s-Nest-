<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Arena: Grandmaster Coach</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /*! chessboard.js v1.0.0 | (c) 2019 Chris Oakman | MIT License chessboardjs.com/license */
        .clearfix-7da63 { clear: both; }
        .board-b72b1 { border: 2px solid #404040; box-sizing: content-box; }
        .board-b72b1 * { box-sizing: content-box; }
        .square-55d63 { float: left; position: relative; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; outline: 1px solid rgba(0,0,0,0.15); outline-offset: -1px; }
        .square-55d63:after, .square-55d63:before { display: table; content: " "; }
        .square-55d63:after { clear: both; }
        .piece-417db { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: pointer; z-index: 50; } 
        .alpha-d2270 { position: absolute; bottom: 1px; right: 3px; font-size: 11px; line-height: 12px; }
        .numeric-fc462 { position: absolute; top: 2px; left: 2px; font-size: 11px; cursor: default; line-height: 12px; }
        
        /* App Styles (Permanently Light Mode) */
        body { background-color: #f1f5f9; font-family: 'Segoe UI', system-ui, sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .navbar { background: #1e1b4b; color: white; padding: 0.5rem 1rem; border-bottom: 1px solid #334155; flex-shrink: 0; z-index: 20; }
        .navbar-brand { color: white; font-weight: 700; font-size: 1.1rem; text-decoration: none; display: flex; align-items: center; gap: 10px; }
        .main-layout { display: flex; flex: 1; overflow: hidden; position: relative; }
        
        .sidebar { width: 320px; background: white; border-right: 1px solid #cbd5e1; display: flex; flex-direction: column; z-index: 10; flex-shrink: 0; transition: margin-left 0.3s ease; }
        .sidebar.collapsed { margin-left: -320px; }
        .sidebar-header { padding: 15px; border-bottom: 1px solid #e2e8f0; background: #f8fafc; display: flex; flex-direction: column; gap: 10px; }
        .game-list { flex: 1; overflow-y: auto; }
        .game-item { padding: 10px 15px; border-bottom: 1px solid #f1f5f9; cursor: pointer; transition: background 0.1s; font-size: 0.9rem; }
        .game-item:hover { background: #f1f5f9; }
        .game-item.active { background: #e0e7ff; border-left: 3px solid #4f46e5; }
        
        .content-area { flex: 1; display: flex; flex-direction: column; min-width: 0; background: #f8fafc; height: 100%; position: relative; }
        
        /* FIX: Tabs for Horizontal Scrolling */
        .mode-tabs { 
            padding: 10px 10px 0 10px; 
            background: #fff; 
            border-bottom: 1px solid #cbd5e1; 
            display: flex; 
            gap: 5px; 
            flex-shrink: 0; 
            overflow-x: auto; /* Allow horizontal scrolling */
            white-space: nowrap; /* Prevent wrapping */
            -webkit-overflow-scrolling: touch; 
        }
        .mode-tab { 
            padding: 8px 16px; 
            cursor: pointer; 
            border-radius: 6px 6px 0 0; 
            font-weight: 600; 
            font-size: 0.9rem; 
            color: #64748b; 
            border: 1px solid transparent; 
            border-bottom: none; 
            display: flex; 
            align-items: center; 
            gap: 6px; 
            flex-shrink: 0; /* Prevent tab shrinking */
        }
        .mode-tab:hover { background: #f8fafc; color: #334155; }
        .mode-tab.active { background: #f8fafc; color: #1e1b4b; border-color: #cbd5e1; border-bottom: 1px solid #f8fafc; margin-bottom: -1px; z-index: 2; }
        
        .arena { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 20px 80px 20px 20px; overflow-y: auto; position: relative; min-height: 0; }
        .board-card { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); width: 100%; max-width: 560px; display: flex; flex-direction: column; gap: 10px; position: relative; transition: all 0.3s; z-index: 5; }
        
        /* Board Wrapper */
        #board-wrapper { position: relative; width: 100%; }
        #board { width: 100%; height: 100%; touch-action: none; z-index: 10; position: relative; }
        #arrowOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        /* Analysis Panel */
        .analysis-panel { 
            flex: 0 0 35vh; 
            min-height: 150px;
            max-height: 50vh;
            background: white; 
            border-top: 1px solid #cbd5e1; 
            display: flex; 
            flex-direction: row; 
            flex-shrink: 0; 
            transition: all 0.3s ease;
            position: relative;
            z-index: 20;
        }
        .analysis-moves { 
            flex: 1; border-right: 1px solid #eee; display: flex; flex-direction: column; position: relative; 
            min-height: 0; 
        }
        .analysis-logs { width: 40%; display: flex; flex-direction: column; background: #0f172a; color: #4ade80; font-family: monospace; font-size: 11px; transition: width 0.3s; }
        .analysis-logs.hidden { display: none !important; }
        .analysis-panel.hidden { display: none !important; }
        
        #analysisListContainer { flex: none; display: none !important; } 
        .analysis-mode-hidden { display: none !important; }

        .log-entry { padding: 6px 12px; border-bottom: 1px solid #f1f5f9; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .log-entry:hover { background: #f8fafc; }
        .log-entry.active { background: #eef2ff; border-left: 4px solid #6366f1; }
        
        .move-class { font-size: 0.65rem; font-weight: 800; padding: 2px 6px; border-radius: 4px; color: white; text-transform: uppercase; letter-spacing: 0.5px; }
        .class-Brilliant { background-color: #1baca6; } .class-Great { background-color: #5c8bb0; } .class-Best { background-color: #96bc4b; } 
        .class-Excellent { background-color: #96bc4b; opacity: 0.8; } .class-Good { background-color: #96bc4b; opacity: 0.6; } 
        .class-Book { background-color: #d5a47d; } .class-Inaccuracy { background-color: #f0c15c; color: #5e4b1e; } 
        .class-Mistake { background-color: #e6912c; } .class-Blunder { background-color: #fa412d; } .class-Missed { background-color: #ff879c; } 
        .class-Neutral { background-color: #a3a3a3; } 

        .coach-display { 
            padding: 15px; 
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); 
            border-bottom: 1px solid #e2e8f0; 
            font-size: 0.95rem; 
            color: #334155; 
            min-height: 0; 
            flex: 1; 
            overflow-y: auto; 
            position: relative; 
            border-left: 4px solid #cbd5e1; 
        }
        .coach-display.Brilliant { border-left-color: #1baca6; background: #e0f2f1; } .coach-display.Great { border-left-color: #5c8bb0; background: #e1f5fe; }
        .coach-display.Best { border-left-color: #96bc4b; background: #f1f8e9; } .coach-display.Excellent { border-left-color: #96bc4b; background: #f1f8e9; }
        .coach-display.Good { border-left-color: #96bc4b; background: #f9fbe7; } .coach-display.Book { border-left-color: #d5a47d; background: #fff3e0; }
        .coach-display.Inaccuracy { border-left-color: #f0c15c; background: #fffde7; } .coach-display.Mistake { border-left-color: #e6912c; background: #fff3e0; }
        .coach-display.Blunder { border-left-color: #fa412d; background: #ffebee; } .coach-display.Missed { border-left-color: #ff879c; background: #fce4ec; }

        .control-row { display: flex; justify-content: center; gap: 5px; margin-top: 5px; }
        .eval-bar-wrapper { width: 100%; height: 8px; background: #475569; border-radius: 4px; overflow: hidden; margin: 5px 0; transition: opacity 0.3s; position: relative; }
        .eval-fill { height: 100%; width: 50%; background: #22c55e; transition: width 0.3s ease-out; }
        .eval-container { transition: opacity 0.3s; }
        .play-mode-blind .eval-container { opacity: 0; pointer-events: none; }
        .material-stats { font-size: 0.9rem; font-weight: 600; color: #475569; display: flex; justify-content: space-between; padding: 6px 10px; background: #f8fafc; border-radius: 4px; margin-top: 5px; border: 1px solid #e2e8f0; }
        .mat-side { display: flex; gap: 2px; align-items: center; min-height: 20px; }
        .mat-label { font-size: 0.7em; text-transform: uppercase; color: #94a3b8; margin-right: 5px; }
        .graveyard-w { color: #000; font-size: 1.2em; display:flex; } .graveyard-b { color: #fff; text-shadow: 0 0 1px #000; font-size: 1.2em; display:flex; } 
        .puzzle-feedback { text-align: center; height: 30px; font-weight: bold; margin-top: 10px; }
        .text-correct { color: #16a34a; } .text-incorrect { color: #dc2626; }
        .puzzle-success { animation: pulse-green 1s; box-shadow: 0 0 15px #22c55e; } .puzzle-fail { animation: shake 0.5s; box-shadow: 0 0 15px #ef4444; }
        .highlight-select { box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.5); }
        .highlight-hint { box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.8) !important; background: rgba(255, 255, 0, 0.2); }
        .highlight-selected { box-shadow: inset 0 0 0 4px rgba(59, 130, 246, 0.8) !important; }
        .opacity-50 { opacity: 0.5; pointer-events: none; }
        .wdl-stats { font-size: 0.7rem; color: #64748b; text-align: center; margin-top: 2px; font-family: monospace; }
        
        /* Draggable Controls (Desktop/Default) */
        #verticalAnalysisControls {
            position: fixed; 
            right: 15px; 
            top: 50%; 
            transform: translateY(-50%); 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
            z-index: 2000;
            background: rgba(255, 255, 255, 0.95); 
            padding: 10px; 
            border-radius: 12px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.25); 
            border: 1px solid #cbd5e1;
            cursor: grab; 
            touch-action: none; 
            transition: none; 
        }
        #verticalAnalysisControls.landscape {
            flex-direction: row; 
            transform: none;
            top: auto !important; 
            left: auto !important; 
            right: auto !important; 
            bottom: auto !important; 
        }
        #verticalAnalysisControls button {
            width: 42px; height: 42px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.2s;
            border: 1px solid #e2e8f0; background: white; color: #334155;
        }
        #verticalAnalysisControls button:hover { background: #f1f5f9; transform: scale(1.05); color: #0f172a; }
        #verticalAnalysisControls button:active { transform: scale(0.95); }
        #verticalAnalysisControls button:disabled { opacity: 0.5; cursor: not-allowed; background: #e2e8f0; }

        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        .checkmate-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 60; display: flex;
            justify-content: center; align-items: center; border-radius: 8px; pointer-events: none;
        }
        .checkmate-text {
            color: #ef4444; font-size: 3rem; font-weight: 900; text-transform: uppercase; text-shadow: 2px 2px 0 #fff; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* TOAST NOTIFICATION */
        .toast-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 9999; }
        .custom-toast {
            background: #334155; color: white; padding: 12px 24px; border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            display: flex; align-items: center; gap: 10px; font-weight: 500; opacity: 0; transform: translateY(20px); transition: all 0.3s ease;
        }
        .custom-toast.show { opacity: 1; transform: translateY(0); }
        .custom-toast.success { background: #065f46; }
        .custom-toast.error { background: #991b1b; }

        /* MOBILE LAYOUT FOR ANALYSIS (Maximized board + scrollable analysis) */
        @media (max-width: 768px) {
            .sidebar { position: absolute; height: 100%; box-shadow: 5px 0 15px rgba(0,0,0,0.2); }
            .sidebar.collapsed { margin-left: -320px; }

            .content-area { 
                overflow-y: auto; 
                height: 100%;
            }
            .arena { 
                padding: 10px 5px 5px 5px !important; 
                overflow-y: visible; 
                height: auto; 
                flex: none;
            }
            .board-card { 
                width: 100% !important; 
                max-width: none; 
                flex-shrink: 0; 
            }
            
            /* Draggable controls remain visible on mobile */
            #verticalAnalysisControls { 
                right: 5px; top: 40%; transform: translateY(-50%); scale: 1; 
                box-shadow: 0 4px 10px rgba(0,0,0,0.4); 
            }
            
            /* Analysis panel is now stacked below the board and flexible */
            .analysis-panel { 
                flex: none; 
                min-height: 200px;
                max-height: none;
                margin: 10px 0;
            }
            .analysis-moves {
                flex: 1;
                width: 100%;
                min-height: 200px;
            }
            .coach-display {
                overflow-y: auto;
                flex: 1; 
                min-height: 100px; 
            }
            .analysis-logs { display: none !important; }
        }
    </style>
</head>
<body>

<nav class="navbar d-flex justify-content-between align-items-center">
    <div class="d-flex align-items-center gap-3">
        <a class="navbar-brand" href="#"><i class="fa-solid fa-chess-knight fa-lg"></i> Chess Arena Pro</a>
        <span class="badge bg-secondary" id="engineStatus">Engine: Init...</span>
    </div>
    <div class="d-flex gap-2">
        <button class="btn btn-sm btn-outline-light" onclick="GUI.toggleSettings()">
            <i class="fa-solid fa-gear"></i>
        </button>
        <button class="btn btn-sm btn-outline-light" onclick="document.getElementById('pgnModal').classList.add('show'); document.getElementById('pgnModal').style.display='block'">
            <i class="fa-solid fa-file-import"></i> Paste PGN
        </button>
        <input type="file" id="csvInput" accept=".csv" class="d-none">
        <button class="btn btn-sm btn-primary" onclick="document.getElementById('csvInput').click()">
            <i class="fa-solid fa-upload me-1"></i> Upload CSV
        </button>
        <button class="btn btn-sm btn-secondary" onclick="GUI.toggleSidebar()" title="Toggle Games List">
            <i class="fa-solid fa-bars"></i>
        </button>
    </div>
</nav>

<div class="main-layout">
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <input type="text" id="searchBox" class="form-control form-control-sm" placeholder="Search opening...">
            <div class="d-flex gap-1">
                <select class="form-select form-select-sm" id="sortSelect" onchange="renderList()">
                    <option value="recent">Recent</option>
                    <option value="oldest">Oldest</option>
                    <option value="acc_high">Accuracy (High)</option>
                    <option value="acc_low">Accuracy (Low)</option>
                    <option value="elo_high">Opp. ELO (High)</option>
                    <option value="elo_low">Opp. ELO (Low)</option>
                </select>
            </div>
        </div>
        <div class="game-list" id="gameList">
            <div class="p-3 text-center text-muted small">Upload CSV or PGN to load games</div>
        </div>
    </div>

    <div class="content-area">
        <div class="mode-tabs">
            <div class="mode-tab active" id="tab-analysis" onclick="GUI.switchTab('analysis')">
                <i class="fa-solid fa-magnifying-glass me-1"></i> Pro Analysis
            </div>
            <div class="mode-tab" id="tab-puzzles" onclick="GUI.switchTab('puzzles')">
                <i class="fa-solid fa-puzzle-piece me-1"></i> Smart Puzzles <span id="puzzleBadge" class="badge bg-danger rounded-pill ms-1 d-none">0</span>
            </div>
            <div class="mode-tab" id="tab-archive" onclick="GUI.switchTab('archive')">
                <i class="fa-solid fa-box-archive me-1"></i> Puzzle Archive <span id="archiveBadge" class="badge bg-secondary rounded-pill ms-1">0</span>
            </div>
            <div class="mode-tab" id="tab-play" onclick="GUI.switchTab('play')">
                <i class="fa-solid fa-robot me-1"></i> Computer Play
            </div>
        </div>

        <div id="verticalAnalysisControls" class="d-none">
            <button onclick="GUI.first()" title="First Move"><i class="fa-solid fa-backward-step"></i></button>
            <button onclick="GUI.prev()" title="Previous Move"><i class="fa-solid fa-chevron-left"></i></button>
            <button onclick="GUI.next()" title="Next Move"><i class="fa-solid fa-chevron-right"></i></button>
            <button onclick="GUI.last()" title="Last Move"><i class="fa-solid fa-forward-step"></i></button>
            <div style="height: 1px; background: #e2e8f0; margin: 2px 5px;"></div>
            <button onclick="GUI.showBestMove()" title="Show Best Move" class="text-primary"><i class="fa-solid fa-star"></i></button>
            <button onclick="GUI.flip()" title="Flip Board"><i class="fa-solid fa-retweet"></i></button>
            <button onclick="GUI.toggleControlsOrientation()" title="Rotate Bar"><i class="fa-solid fa-rotate"></i></button>
        </div>

        <div class="arena">
            <div class="board-card" id="boardCard">
                
                <div class="d-flex justify-content-between align-items-center mb-2" id="boardHeaderContainer">
                    <div id="boardHeaderLeft">
                        <strong id="gameTitle" class="text-truncate d-block" style="max-width: 250px;">Practice Board</strong>
                    </div>
                    <div id="puzzleStatusHeader" class="d-none flex-grow-1 text-center">
                        <span class="badge bg-warning text-dark" id="puzzleCountBadge">Puzzle 0/0</span>
                    </div>
                    <div class="d-flex align-items-center gap-2" id="boardHeaderRight">
                        <div class="form-check form-switch m-0 d-none" id="puzzleEngineContainer">
                            <input class="form-check-input" type="checkbox" id="puzzleVsEngine" onchange="PuzzleManager.toggleEngineMode()">
                            <label class="form-check-label small fw-bold" for="puzzleVsEngine">Vs Engine</label>
                        </div>
                    </div>
                </div>

                <div id="board-wrapper">
                    <div id="board"></div>
                    <svg id="arrowOverlay"></svg>
                    <div id="checkmateOverlay" class="checkmate-overlay d-none">
                        <div class="checkmate-text">CHECKMATE</div>
                    </div>
                </div>
                
                <div id="evalContainer" class="eval-container">
                    <div class="eval-bar-wrapper" id="evalBar">
                        <div class="eval-fill" id="evalFill"></div>
                    </div>
                    <div class="d-flex justify-content-between small text-muted px-1" id="evalTextContainer">
                        <span id="evalValue">0.00</span>
                        <span id="wdlValue" class="wdl-stats">Win: 50%</span>
                    </div>
                </div>
                
                <div class="material-stats" id="materialDisplay">
                    <div class="mat-side"><span class="mat-label">W Captured:</span><div class="graveyard-w" id="matWhite"></div></div>
                    <div class="mat-side"><span class="mat-label">B Captured:</span><div class="graveyard-b" id="matBlack"></div></div>
                </div>

                <div id="puzzleFeedback" class="puzzle-feedback d-none"></div>

                <div id="analysisControls" class="d-none"><div class="control-row"></div></div>

                <div id="puzzleControls" class="d-none">
                    <div class="control-row">
                        <button class="btn btn-sm btn-outline-secondary w-25" onclick="PuzzleManager.prev()" title="Previous Puzzle"><i class="fa-solid fa-chevron-left"></i></button>
                        <button class="btn btn-sm btn-secondary w-50" onclick="PuzzleManager.skip()">Skip</button>
                        <button class="btn btn-sm btn-outline-secondary w-25" onclick="PuzzleManager.next()" title="Next Puzzle"><i class="fa-solid fa-chevron-right"></i></button>
                    </div>
                    <div class="control-row mt-2">
                         <button class="btn btn-sm btn-success w-100" onclick="GUI.hint()"><i class="fa-solid fa-lightbulb"></i> Hint</button>
                    </div>
                    <div class="mt-3 pt-2 border-top">
                        <div class="d-flex justify-content-between">
                            <label class="small fw-bold text-muted">Puzzle Depth (User Moves)</label>
                            <span class="badge bg-primary" id="puzzleDepthLabel">1 Move</span>
                        </div>
                        <input type="range" class="form-range" min="1" max="5" value="1" id="puzzleDepthRange" oninput="PuzzleManager.updateDepth(this.value)">
                    </div>
                </div>

                <div id="playControls" class="d-none">
                      <div class="control-row">
                        <button class="btn btn-sm btn-outline-secondary" onclick="GUI.prev()"><i class="fa-solid fa-chevron-left"></i></button>
                        <button class="btn btn-sm btn-outline-secondary" onclick="GUI.next()"><i class="fa-solid fa-chevron-right"></i></button>
                        <button class="btn btn-sm btn-dark" onclick="GUI.flip('play')"><i class="fa-solid fa-retweet"></i> Flip Side</button>
                    </div>
                    <div class="control-row">
                         <button class="btn btn-sm btn-warning w-50" onclick="GUI.undoPlayMove()"><i class="fa-solid fa-rotate-left"></i> Undo</button>
                         <button class="btn btn-sm btn-danger w-50" onclick="GUI.resetGame()"><i class="fa-solid fa-trash-can"></i> Reset</button>
                    </div>
                      <div class="control-row">
                         <button class="btn btn-sm btn-outline-secondary w-100" onclick="GUI.copyPGN()"><i class="fa-solid fa-copy"></i> PGN</button>
                    </div>
                    <div class="mt-3 pt-2 border-top">
                        <div class="d-flex justify-content-between">
                            <label class="small fw-bold text-muted">Stockfish Strength</label>
                            <span class="badge bg-primary" id="eloLabel">ELO: 1200</span>
                        </div>
                        <input type="range" class="form-range" min="0" max="20" value="5" id="skillRange" oninput="GUI.updateEloLabel(this.value); Engine.setSkill(this.value)">
                    </div>
                </div>

            </div>
            
            <div id="puzzleArchivePanel" class="d-none board-card" style="max-width: 600px; padding: 20px;">
                <h5 class="fw-bold">Puzzle Archive (<span id="archiveCount">0</span> Puzzles)</h5>
                <div class="d-flex gap-2 mb-3">
                    <button class="btn btn-primary w-100" onclick="ArchiveManager.startRandom()"><i class="fa-solid fa-shuffle"></i> Start Random Puzzle from Archive</button>
                </div>
                <div id="archiveListInfo" class="text-center text-muted p-3">
                     Puzzles loaded in the archive are available for random training.
                </div>
            </div>

        </div>

        <div class="analysis-panel" id="analysisPanel">
            <div class="analysis-moves">
                <div class="sidebar-header d-flex justify-content-between align-items-center bg-light">
                    <strong>Analysis Report</strong>
                    <div class="d-flex gap-1">
                        <select id="analysisFocus" class="form-select form-select-sm" style="width: 80px;">
                            <option value="both">Both</option>
                            <option value="w">White</option>
                            <option value="b">Black</option>
                        </select>
                        <button class="btn btn-sm btn-outline-dark" onclick="GUI.copyAnalysis()" title="Copy Full Analysis">
                             <i class="fa-solid fa-copy"></i>
                        </button>
                        <button class="btn btn-sm btn-primary" id="scanBtn" onclick="Scanner.start()">
                            <i class="fa-solid fa-wand-magic-sparkles me-1"></i> Full Analysis
                        </button>
                    </div>
                </div>
                
                <div class="p-2 bg-light border-bottom d-none" id="scanProgress">
                    <div class="progress" style="height: 5px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" id="scanBar" style="width: 0%"></div>
                    </div>
                    <div class="text-center small text-muted mt-1" id="scanText">Analyzing...</div>
                </div>

                <div class="coach-display" id="coachDisplay">
                    <div class="text-center text-muted" style="margin-top: 20px;">
                        <i class="fa-solid fa-user-graduate fa-2x mb-2"></i><br>
                        Ready for analysis. Press "Full Analysis" to get insights.
                    </div>
                </div>

                <div id="analysisListContainer">
                     <div class="log-container" id="analysisList">
                        <div class="text-center text-muted mt-5 small">Select a game to start.</div>
                    </div>
                </div>
            </div>
            
            <div class="analysis-logs hidden" id="logPanel">
                <div class="p-2 border-bottom border-secondary bg-dark text-white small d-flex justify-content-between align-items-center">
                    <strong>System Log</strong>
                    <button class="btn btn-sm btn-outline-light" style="font-size: 0.7rem; padding: 1px 5px;" onclick="GUI.copyLogs()" title="Copy Logs">
                        <i class="fa-solid fa-clipboard me-1"></i> Copy Logs
                    </button>
                </div>
                <div class="sys-log" id="sysLog">System Initialized.</div>
            </div>
        </div>

    </div>
</div>

<div class="toast-container" id="toastContainer"></div>

<div class="modal fade" id="settingsModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Settings</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="showEvalToggle" checked onchange="GUI.toggleEvalBar(this.checked)">
            <label class="form-check-label" for="showEvalToggle">Show Eval Bar (Computer Play)</label>
        </div>
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="showLogsSwitch" onchange="GUI.toggleLogs(this.checked)">
            <label class="form-check-label" for="showLogsSwitch">Show System Logs</label>
        </div>
        <hr>
        <div class="mb-3">
            <label class="form-label small fw-bold">Gemini API Key</label>
            <input type="password" id="apiKeyInput" class="form-control form-control-sm" placeholder="Paste Key Here...">
            <button class="btn btn-sm btn-outline-primary mt-2" onclick="localStorage.setItem('gemini_api_key', document.getElementById('apiKeyInput').value); GUI.showToast('Key Saved!', 'success')">Save Key</button>
        </div>
        <hr>
        <h6 class="mt-4">Data Management</h6>
        <button class="btn btn-sm btn-danger w-100" onclick="ArchiveManager.clearArchive()">
            <i class="fa-solid fa-trash-can me-2"></i> Clear All Archived Puzzles
        </button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="pgnModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Paste PGN</h5>
        <button type="button" class="btn-close" onclick="document.getElementById('pgnModal').style.display='none'; document.getElementById('pgnModal').classList.remove('show')"></button>
      </div>
      <div class="modal-body">
        <textarea id="pgnText" class="form-control" rows="8" placeholder="[Event ...] 1. e4 e5 ..."></textarea>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" onclick="importManualPGN()">Import Game</button>
      </div>
    </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
// --- CONFIG ---
const STOCKFISH_URL = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
// FIX 1: UPDATED ENDPOINT (Removed -preview-09-2025)
const MODEL_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
const apiKey = ""; 

/**
 * UTILITIES
 */
window.sys_logs = []; 
function log(msg, type = 'INFO') {
    const box = document.getElementById('sysLog');
    const now = new Date();
    const time = now.toLocaleTimeString().split(' ')[0];
    
    window.sys_logs.push({ timestamp: now.toISOString(), type: type, message: msg });
    
    const div = document.createElement('div');
    
    let color = '#4ade80'; 
    if (type === 'ERROR') color = '#f87171'; 
    else if (type === 'WARN') color = '#facc15'; 
    
    div.innerHTML = `<span style="color: ${color};">[${type}]</span> [${time}] ${msg}`;
    div.className = 'log-line'; 
    if(box) {
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }
}

function getEffectiveKey() {
    if(apiKey && apiKey.length > 0) return apiKey;
    return localStorage.getItem('gemini_api_key') || "";
}

/**
 * ENGINE (Stockfish)
 */
const Engine = {
    worker: null,
    isReady: false,
    
    init: function() {
        log("Loading Stockfish 10.0.2...");
        try {
            const blob = new Blob([`importScripts('${STOCKFISH_URL}');`], {type: 'application/javascript'});
            this.worker = new Worker(URL.createObjectURL(blob));
            this.worker.postMessage('uci');
            this.worker.postMessage('setoption name UCI_ShowWDL value true'); 
            this.worker.onmessage = (e) => this.handleMessage(e.data);
            this.worker.onerror = (e) => {
                log("Engine Worker Error: " + e.message, 'ERROR');
                document.getElementById('engineStatus').className = "badge bg-danger";
                document.getElementById('engineStatus').innerText = "Failed";
            };
        } catch(e) { 
            log("Engine Init Error: " + e, 'ERROR'); 
            document.getElementById('engineStatus').className = "badge bg-danger";
            document.getElementById('engineStatus').innerText = "Failed";
        }
    },

    handleMessage: function(line) {
        if(line === 'uciok') {
            this.isReady = true;
            document.getElementById('engineStatus').className = "badge bg-success";
            document.getElementById('engineStatus').innerText = "Ready";
            log("Stockfish Ready.");
        }
    },

    setSkill: function(val) {
        if(!this.isReady) return;
        this.worker.postMessage(`setoption name Skill Level value ${val}`);
        const err = Math.max(0, 20 - val) * 20;
        this.worker.postMessage(`setoption name Skill Level Probability value ${err}`);
    },

    stop: function() {
        if(this.isReady) this.worker.postMessage('stop');
    },

    runScan: function(fen) {
        return new Promise(resolve => {
            if(!this.isReady) {
                resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null });
                return;
            }
            
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;

            const tId = setTimeout(() => {
                this.worker.onmessage = oldHandler; 
                resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null });
            }, 6000); 

            let best="-", ev="0.00", pv="", wdl=null;

            const list = (e) => {
                const l = e.data;
                if (l.includes(' pv ')) pv = l.split(' pv ')[1];
                if (l.includes(' wdl ')) { const m=l.match(/wdl (\d+) (\d+) (\d+)/); if(m) wdl=[parseInt(m[1]), parseInt(m[2]), parseInt(m[3])]; }
                if (l.includes('cp ')) { const m=l.match(/cp (-?\d+)/); if(m) ev=(parseInt(m[1])/100 * (fen.includes(' b ')?-1:1)).toFixed(2); }
                if (l.includes('mate ')) { const m=l.match(/mate (-?\d+)/); if(m) ev="M"+(parseInt(m[1])); }
                
                if (l.startsWith('bestmove')) {
                    clearTimeout(tId);
                    best = l.split(' ')[1];
                    this.worker.onmessage = oldHandler; 
                    if(!wdl && !ev.toString().startsWith('M')) wdl = this.estimateWDL(parseFloat(ev));
                    resolve({ eval: ev, bestMove: best, pv: pv, wdl: wdl });
                }
            };
            this.worker.onmessage = (e) => list(e);
            
            this.worker.postMessage('stop');
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 12'); 
        });
    },

    estimateWDL: function(ev) {
        const w = 1000 / (1 + Math.exp(-ev));
        const l = 1000 - w;
        return [Math.round(w), 0, Math.round(l)];
    },

    getBestMove: function(fen) {
        return new Promise(resolve => {
            if(!this.isReady) resolve(null);
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;
            const listener = (e) => {
                if(e.data.startsWith('bestmove')) {
                    const move = e.data.split(' ')[1];
                    this.worker.onmessage = oldHandler;
                    resolve(move);
                }
            };
            this.worker.onmessage = (e) => listener(e);
            this.worker.postMessage('stop');
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 12');
        });
    },
    
    analyze: function(fen) {
        if(!this.isReady) return;
        this.worker.postMessage('stop'); 
        this.worker.postMessage(`position fen ${fen}`);
        this.worker.postMessage('go depth 14');
        
        const listener = (e) => {
            const line = e.data;
            let cp = 0, mate = null;
            
            if(line.includes('score mate')) {
                const m = line.match(/score mate (-?\d+)/);
                if(m) mate = parseInt(m[1]);
            } else if(line.includes('score cp')) {
                const m = line.match(/score cp (-?\d+)/);
                if(m) cp = parseInt(m[1]);
            }

            if (line.includes(' pv ')) {
                let activeColor = fen.split(' ')[1];
                let evalVal = cp;
                if(activeColor === 'b') {
                    evalVal = -cp;
                    if(mate !== null) mate = -mate;
                }
                if (Game.getActiveChess().fen().split(' ')[0] === fen.split(' ')[0]) {
                    GUI.updateEval(evalVal, mate);
                }
            }
            if(line.startsWith('bestmove')) this.worker.removeEventListener('message', listener);
        };
        this.worker.addEventListener('message', listener);
    },
    
    playResponse: function(fen) {
          if(!this.isReady) return;
          
          this.worker.postMessage('stop'); 
          
          const watchdog = setTimeout(() => {
              log("WARN: Engine timed out (3s). Forcing stop and reset.", 'WARN');
              this.worker.removeEventListener('message', listener);
              this.worker.postMessage('stop');
              this.worker.postMessage('ucinewgame'); 
              document.getElementById('boardCard').classList.remove('opacity-50');
          }, 3000); 

          this.worker.postMessage(`position fen ${fen}`);
          this.worker.postMessage('go movetime 1500'); 
          
          const listener = (e) => {
              if(e.data.startsWith('bestmove')) {
                  clearTimeout(watchdog); 
                  const best = e.data.split(' ')[1];
                  this.worker.removeEventListener('message', listener);
                  Game.engineMove(best);
              }
          };
          this.worker.addEventListener('message', listener);
    },

    getTopMoves: function(fen, count) {
        return new Promise(resolve => {
            if(!this.isReady) resolve([]);
            let moves = [];
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;
            const listener = (e) => {
                const line = e.data;
                if(line.startsWith('info') && line.includes('multipv') && line.includes('pv')) {
                    const parts = line.split(' pv ');
                    if(parts[1]) {
                        const m = parts[1].split(' ')[0];
                        if (!moves.includes(m)) moves.push(m);
                    }
                }
                if(line.startsWith('bestmove')) {
                    this.worker.onmessage = oldHandler;
                    resolve(moves);
                }
            };
            this.worker.onmessage = (e) => listener(e);
            this.worker.postMessage('stop');
            this.worker.postMessage(`setoption name MultiPV value ${count}`);
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 10'); 
            setTimeout(() => this.worker.postMessage('setoption name MultiPV value 1'), 500); 
        });
    }
};
window.Engine = Engine;

/**
 * TACTICAL HEAT MAP ENGINE - V3 (Comprehensive Board Awareness)
 * Optimized for Token Efficiency
 */
const HeatMap = {
    val: { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 }, // Normalized: King = 0 for trades
    
    // Core Entry Point
    analyze: function(chess) {
        const fen = chess.fen();
        
        let report = {
            exchange: {},
            pins: [],
            threats: []
        };

        const board = chess.board();
        const files = ['a','b','c','d','e','f','g','h'];

        // 1. Static Exchange Evaluation (SEE) for every square
        for(let r=0; r<8; r++){
            for(let c=0; c<8; c++){
                // We only need to check squares relevant to the position
                const piece = board[r][c];
                const sq = files[c] + (8-r);
                
                const exchange = this.getExchangeAnalysis(chess, sq);
                // Only store if there is actual activity (attackers present)
                if (exchange.attackers.length > 0) {
                    report.exchange[sq] = exchange;
                }
            }
        }

        // 2. Pin Detection
        report.pins = this.getPinMap(chess);

        return report;
    },

    getExchangeAnalysis: function(chess, square) {
        const turn = chess.turn();
        const opp = turn === 'w' ? 'b' : 'w';
        const temp = new Chess(chess.fen());
        const attackers = this.getAttackers(temp, square, opp); 
        const defenders = this.getAttackers(temp, square, turn); 
        
        // Calculate raw material power on square
        const atkVal = attackers.reduce((acc, p) => acc + (this.val[p.toLowerCase()] || 0), 0);
        const defVal = defenders.reduce((acc, p) => acc + (this.val[p.toLowerCase()] || 0), 0);
        const net = defVal - atkVal;

        // Determine status
        let status = "Safe";
        if (attackers.length > defenders.length) status = "Lost";
        else if (attackers.length > 0) status = "Contested";

        return {
            attackers: attackers,
            defenders: defenders,
            atkValue: atkVal,
            defValue: defVal,
            net: net,
            status: status
        };
    },

    getAttackers: function(chess, sq, color) {
        const temp = new Chess(chess.fen());
        const tokens = chess.fen().split(' ');
        tokens[1] = color;
        tokens[3] = '-'; 
        temp.load(tokens.join(' '));
        
        const colorMoves = temp.moves({ verbose: true });
        const attackers = [];
        
        colorMoves.forEach(m => {
            if (m.to === sq) attackers.push(m.piece.toUpperCase());
        });
        
        return attackers;
    },

    getPinMap: function(chess) {
        return [];
    },
    
    // OPTIMIZED FORMATTER: Reduces token usage by ~90% to prevent API limits
    formatForAI: function(report) {
        let txt = ""; 
        for (const [sq, data] of Object.entries(report.exchange)) {
            // CRITICAL CHANGE: Only report squares that are actually dangerous or complex.
            // We ignore "Safe" squares where defenders >= attackers to save massive amounts of tokens.
            if (data.status === 'Lost' || (data.status === 'Contested' && data.atkValue > 1)) {
                txt += `[${sq}: ${data.status} (Net ${data.net}, AtkVal ${data.atkValue})] `;
            }
        }
        return txt ? "Radar: " + txt : "";
    }
};
window.HeatMap = HeatMap;
            

/**
 * GEMINI AI
 */
const Gemini = {
    comments: {}, 
    getCommentary: async function(analysisData, openingName, focus) {
        const k = getEffectiveKey();
        if (!k) { GUI.showToast("Please set API Key in Settings!", "error"); return false; }

        let logStr = `Game Context:\nOpening: ${openingName}\n\n`;
        
        analysisData.forEach((d, i) => {
            const isUserTurn = (focus === 'both' || focus === d.color);
            if (!isUserTurn) return;

            let evalText = d.eval;
            if(d.eval.toString().startsWith('M')) evalText = `Mate in ${d.eval.replace('M','')}`;

            const moveInfo = `[PLY ${i+1}] ${d.color==='w'?'White':'Black'} played ${d.san}`;
            const engineInfo = `\n    - Best Move: ${d.bestMoveSan || '?'}`;
            const engineLine = `\n    - PV (Engine Plan): ${d.pvSan || 'None'}`;
            
            let tacticalText = "\n    " + HeatMap.formatForAI(d.tactics);

            const outcome = `\n    - Result: Eval ${evalText}, Class ${d.classification}`;
            
            logStr += `${moveInfo} ${tacticalText} ${engineInfo} ${engineLine} ${outcome}\n\n`;
        });

        if (logStr.length < 50) logStr = "Game was short.";

        const prompt = `
You are a Grandmaster Chess Coach.

**YOUR DATA SOURCE:**
For every move, I have provided:
1. The Move & Engine Best Move.
2. **Tactical Radar:** This gives you a comprehensive exchange analysis for every contested square.
   - Example: "e4: Attacked by [N,P] (Val: 4), Defended by [K] (Val: 0). Net Defense: -4. Status: Lost".
   - Use this to identify undefended pieces, bad trades, and tactical oversights based on the *Net Defense* value.
3. **Principal Variation (PV):** The future moves the engine predicts.

**CRITICAL INSTRUCTIONS:**
1. **No Meta-Talk:** Do NOT mention phrases like "The Tactical Radar shows", "The data indicates", or "My sensors detect". Speak naturally, like a human coach looking at the board.
2. **Book Moves:** If a move is classified as 'Book', explain the strategic opening principle (e.g., controlling center, developing pieces). DO NOT CRITICIZE IT.
3. **Defensive Logic:** If a move defends a piece that was listed as 'Attacked', acknowledge the defense. 
4. **JSON ONLY:** Return *only* the JSON object.

**TASK:**
Explain the moves in the provided game log.

**JSON Format:**
{
    "12": {
        "analysis": "This pawn push is a mistake. Your Knight on f3 was overwhelmed (2 attackers vs 1 defender), and this move unpins it but loses material.",
        "pv_explanation": ["Nf3 prevents the fork", "Be2 prepares castling"] 
    }
}

**Game Log:**
${logStr}
        `;

        try {
            log("Sending rich context request to Gemini...");
            
            const res = await fetch(MODEL_ENDPOINT+`?key=${k}`, {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });

            const d = await res.json();
            
            // FIX 2: IMPROVED ERROR LOGGING
            if (d.error) {
                log(`Gemini API Error: ${d.error.message}`, 'ERROR');
                GUI.showToast(`API Error: ${d.error.message}`, "error");
                return false;
            }

            if(!d.candidates || !d.candidates[0]) {
                log("Gemini API returned no content.", 'ERROR');
                return false;
            }
            const text = d.candidates[0].content.parts[0].text;
            let cleanText = text.replace(/```json/g, '').replace(/```/g, '');
            const start = cleanText.indexOf('{');
            const end = cleanText.lastIndexOf('}');
            if (start !== -1 && end !== -1) {
                cleanText = cleanText.substring(start, end + 1);
                this.comments = JSON.parse(cleanText);
                log("Gemini Analysis Complete.");
                return true;
            }
            log("Gemini response was not valid JSON or complete.", 'ERROR');
            return false;
        } catch (e) { 
            console.error("Gemini Error", e);
            if (e.name === 'AbortError') {
                log("Coach Analysis Failed (Request Aborted). Retrying or check network.", 'ERROR');
            } else {
                GUI.showToast("Coach Analysis Failed (Network/API). Check System Log.", 'ERROR');
            }
            return false; 
        }
    }
};
window.Gemini = Gemini;

/**
 * GAME LOGIC
 */
// SAFE LOCAL STORAGE PARSING
function safeParse(key, fallback) {
    try {
        const item = localStorage.getItem(key);
        return item ? JSON.parse(item) : fallback;
    } catch(e) { return fallback; }
}

const Game = {
    data: [],
    
    // FOUR Separate Board States for Maximum Independence
    analysisChess: new Chess(),
    playChess: new Chess(),
    smartChess: new Chess(), // DEDICATED for Smart Puzzles
    archiveChess: new Chess(), // DEDICATED for Archive Puzzles
    
    history: [],
    index: -1,
    userColor: 'w',
    playUserColor: 'w', 
    playViewIndex: -1, 
    analysisData: [], 
    generatedPuzzles: [], // Puzzles from analysis
    puzzleArchive: safeParse('chess_puzzles', []), 
    mode: 'analysis',
    puzzleSource: null, // 'current' or 'archive'
    selectedSquare: null, 
    
    // STORAGE
    save: function() {
        localStorage.setItem('chess_games', JSON.stringify(this.data));
    },
    
    saveArchive: function() {
        localStorage.setItem('chess_puzzles', JSON.stringify(this.puzzleArchive));
    },

    loadFromStorage: function() {
        const d = localStorage.getItem('chess_games');
        if(d) {
            try { this.data = JSON.parse(d); } catch(e){ this.data = []; }
            renderList();
        }
    },

    // Helper to get active instance based on mode
    getActiveChess: function() {
        if (this.mode === 'play') {
             if (this.playViewIndex !== -1) {
                 const temp = new Chess();
                 const history = this.playChess.history({ verbose: true });
                 for (let i = 0; i <= this.playViewIndex; i++) {
                     temp.move(history[i].san);
                 }
                 return temp;
             }
             return this.playChess;
        } else if (this.mode === 'puzzles') {
            return this.smartChess;
        } else if (this.mode === 'archive') {
            return this.archiveChess;
        }
        return this.analysisChess;
    },

    cleanPGN: function(pgn) {
        if (!pgn) return "";
        let body = pgn.replace(/\[.*?\]/g, ' ').replace(/\{.*?\}/g, ' ').replace(/\(.*?\)/g, ' ').replace(/\$\d+/g, ' ');
        return body.replace(/\s+/g, ' ').trim();
    },

    load: function(id) {
        // Confirmation dialog logic: If analysis is complete/running, confirm switch.
        const isActiveAnalysis = Game.analysisData.length > 0;
        const inMiddleOfGame = Game.index > -1;
        
        if (isActiveAnalysis || inMiddleOfGame) {
            if (!confirm("Analysis is running or complete. Switching games will clear current analysis data. Continue?")) {
                return; 
            }
        }

        const g = this.data.find(x => x.id === id);
        if(!g) return;
        
        log(`Loading Game ID ${id}...`);
        this.analysisChess.reset();
        
        const movesOnly = this.cleanPGN(g.pgn);
        let success = this.analysisChess.load_pgn(movesOnly);
        if(!success) success = this.analysisChess.load_pgn(g.pgn);
        
        if(!success) {
            log("ERROR: PGN Parse Failed.", 'ERROR');
            return;
        }
        
        this.history = this.analysisChess.history({ verbose: true });
        this.resetToStart();
        
        document.getElementById('gameTitle').innerText = g.opening;
        document.getElementById('scanBtn').disabled = false;
        
        this.analysisData = [];
        this.generatedPuzzles = [];
        Gemini.comments = {};
        
        GUI.renderAnalysisList();
        GUI.resetCoachDisplay();
        
        document.getElementById('puzzleBadge').classList.add('d-none');
        document.getElementById('boardCard').classList.remove('opacity-50');

        let rawColor = (g.userColor || 'white').toLowerCase();
        this.userColor = rawColor.startsWith('b') ? 'b' : 'w';
        
        GUI.board.orientation(this.userColor === 'b' ? 'black' : 'white');
        GUI.switchTab('analysis');
        setTimeout(() => GUI.board.resize(), 100);
    },
    
    resetToStart: function() {
        this.analysisChess.reset();
        this.index = -1;
        GUI.update();
        Engine.analyze(this.analysisChess.fen());
    },
    
    move: function(from, to, prom) {
        const chess = this.getActiveChess();
        
        if (this.mode === 'play' && this.playViewIndex !== -1) return false;
        
        const move = chess.move({ from: from, to: to, promotion: prom || 'q' });
        
        if(move) {
            if (this.mode === 'analysis') {
                this.index++; 
                GUI.update();
                Engine.analyze(chess.fen());
            } 
            else if (this.mode === 'play') {
                this.playViewIndex = -1; 
                GUI.board.position(this.playChess.fen()); 
                GUI.update();
                if (this.playChess.in_checkmate()) document.getElementById('checkmateOverlay').classList.remove('d-none');
                
                if (!this.playChess.game_over()) {
                    Engine.playResponse(this.playChess.fen());
                }
                Engine.analyze(this.playChess.fen());
            }
            // Puzzles/Archive have their own handlers in PuzzleManager
            GUI.clearArrows();
            return true;
        }
        return false;
    },

    engineMove: function(bestMoveUci) {
        if (this.mode !== 'play') return;
        
        const from = bestMoveUci.substring(0,2);
        const to = bestMoveUci.substring(2,4);
        const prom = bestMoveUci.length > 4 ? bestMoveUci.substring(4,5) : 'q';
        
        this.playChess.move({ from: from, to: to, promotion: prom });
        GUI.board.position(this.playChess.fen()); 
        GUI.update();
        if (this.playChess.in_checkmate()) document.getElementById('checkmateOverlay').classList.remove('d-none');
        Engine.analyze(this.playChess.fen());
    },
    
    navPlay: function(dir) {
        const history = this.playChess.history({ verbose: true });
        const len = history.length;
        
        const lastMoveIndex = len - 1;

        if (dir === 'next') {
            this.playViewIndex = Math.min(lastMoveIndex, this.playViewIndex + 1);
        } else if (dir === 'prev') {
            this.playViewIndex = Math.max(-1, this.playViewIndex - 1);
        } else if (dir === 'first') {
            this.playViewIndex = -1; 
        } else if (dir === 'last') {
            this.playViewIndex = lastMoveIndex;
        }

        const tempChess = new Chess();
        if (this.playViewIndex >= 0) {
            for (let i = 0; i <= this.playViewIndex; i++) {
                tempChess.move(history[i].san);
            }
            GUI.board.position(tempChess.fen());
            document.getElementById('boardCard').classList.add('opacity-50');
        } else {
            GUI.board.position(this.playChess.fen());
            document.getElementById('boardCard').classList.remove('opacity-50');
            Engine.analyze(this.playChess.fen());
        }
        GUI.clearArrows();
    },

    nav: function(dir) {
        if (this.mode === 'play') {
            this.navPlay(dir);
            return;
        }
        
        // Navigation only applies to analysis mode
        if (this.mode !== 'analysis') return;

        document.getElementById('checkmateOverlay').classList.add('d-none');
        GUI.clearArrows();
        
        if(dir === 'next' && this.index < this.history.length - 1) {
            this.index++;
            this.analysisChess.move(this.history[this.index].san);
        } else if (dir === 'prev' && this.index >= 0) {
            this.analysisChess.undo();
            this.index--;
        } else if (dir === 'first') {
            this.analysisChess.reset();
            this.index = -1;
        } else if (dir === 'last') {
            while(this.index < this.history.length - 1) {
                this.index++;
                this.analysisChess.move(this.history[this.index].san);
            }
        }
        GUI.update();
        Engine.analyze(this.analysisChess.fen());
    }
};
window.Game = Game;

/**
 * SCANNER - The Truth Pipeline
 */
const Scanner = {
    start: async function() {
        const btn = document.getElementById('scanBtn');
        const bar = document.getElementById('scanBar');
        const text = document.getElementById('scanText');
        const progressBox = document.getElementById('scanProgress');
        const focus = document.getElementById('analysisFocus').value;
        const navBtns = document.querySelectorAll('#verticalAnalysisControls button');

        if (!Game.history || Game.history.length === 0) {
            GUI.showToast("No moves to analyze!", "error");
            return;
        }

        btn.disabled = true;
        navBtns.forEach(b => b.disabled = true);
        
        progressBox.classList.remove('d-none');
        bar.style.width = '0%';
        bar.className = "progress-bar progress-bar-striped progress-bar-animated"; 
        
        try {
            Game.analysisData = []; 
            Game.generatedPuzzles = [];
            
            const moves = Game.history;
            const tempChess = new Chess();
            
            for(let i=0; i<moves.length; i++) {
                await new Promise(r => setTimeout(r, 20));

                const fenBefore = tempChess.fen();
                
                let isBook = false;
                if (i < 15) {
                    const bookResult = await this.fetchBookData(fenBefore);
                    if (bookResult) {
                        const bookMoves = bookResult.moves.map(m => m.uci);
                        const moveObj = moves[i];
                        const userUci = moveObj.from + moveObj.to + (moveObj.promotion || '');
                        if (bookMoves.includes(userUci)) isBook = true;
                    }
                }

                const tacticalSnapshot = HeatMap.analyze(tempChess);

                const preMoveResult = await Engine.runScan(fenBefore);
                let scoreBefore = this.parseEval(preMoveResult.eval);
                
                let bestMoveSan = preMoveResult.bestMove;
                let bestLineSan = "";

                if(preMoveResult.bestMove && preMoveResult.bestMove !== '-') {
                    const simGame = new Chess(fenBefore);
                    const bm = simGame.move({ from: preMoveResult.bestMove.substring(0,2), to: preMoveResult.bestMove.substring(2,4), promotion: 'q' });
                    if(bm) bestMoveSan = bm.san;
                    if(preMoveResult.pv) bestLineSan = this.uciToSan(fenBefore, preMoveResult.pv);
                }

                const moveObj = moves[i];
                const userUci = moveObj.from + moveObj.to + (moveObj.promotion || '');
                
                tempChess.move(moveObj.san);
                const fenAfter = tempChess.fen();
                
                const isMate = tempChess.in_checkmate();
                let scoreAfter = 0;
                let evAfterStr = "";

                if (isMate) {
                    scoreAfter = (moveObj.color === 'w') ? 100 : -100;
                    evAfterStr = "M0"; 
                } else {
                    const postMoveResult = await Engine.runScan(fenAfter);
                    evAfterStr = postMoveResult.eval;
                    scoreAfter = this.parseEval(postMoveResult.eval);
                }

                let evalLoss = (moveObj.color === 'w') ? scoreBefore - scoreAfter : scoreAfter - scoreBefore;
                if (moveObj.color === 'b') evalLoss = -evalLoss;
                let cls = "Neutral";
                let loss = 0;
                if (moveObj.color === 'w') loss = scoreBefore - scoreAfter;
                else loss = scoreAfter - scoreBefore;
                
                if (isBook) cls = "Book";
                else if (isMate) cls = "Best";
                else if (userUci === preMoveResult.bestMove) cls = "Best";
                else {
                    const wasWinning = (moveObj.color === 'w' ? scoreBefore > 2 : scoreBefore < -2);
                    const isWinning = (moveObj.color === 'w' ? scoreAfter > 1 : scoreAfter < -1);
                    
                    if (wasWinning && !isWinning) cls = "Missed"; 
                    else if (loss >= 2.0) cls = "Blunder";
                    else if (loss >= 1.0) cls = "Mistake";
                    else if (loss >= 0.5) cls = "Inaccuracy";
                    else if (loss >= 0.2) cls = "Good";
                    else if (loss >= 0.05) cls = "Excellent";
                    else cls = "Best"; 
                }
                
                const data = {
                    san: moveObj.san, color: moveObj.color,
                    eval: evAfterStr, 
                    evalDiff: loss.toFixed(2),
                    wdl: preMoveResult.wdl,
                    bestMoveSan: bestMoveSan,
                    pvSan: bestLineSan,
                    classification: cls,
                    fenBefore: fenBefore,
                    isMate: isMate,
                    tactics: tacticalSnapshot
                };

                Game.analysisData.push(data);
                
                if ((cls === 'Blunder' || cls === 'Mistake' || cls === 'Missed') && moveObj.color === Game.userColor) {
                    const puzzle = { fen: fenBefore, color: moveObj.color, solution: preMoveResult.bestMove, date: Date.now() };
                    
                    // Push to generated list
                    Game.generatedPuzzles.push(puzzle);
                    
                    // Duplication Safeguard: Check if identical FEN (pieces, color, castling, ep) exists
                    // We ignore halfmove clock and fullmove number for puzzle identity
                    const getHash = (f) => f.split(' ').slice(0, 4).join(' ');
                    const pHash = getHash(puzzle.fen);

                    const exists = Game.puzzleArchive.some(p => getHash(p.fen) === pHash);
                    
                    if (!exists) {
                        Game.puzzleArchive.push(puzzle);
                        Game.saveArchive();
                        GUI.updateArchiveCount();
                    }
                }

                // Update UI badge if user is viewing somewhere else
                if (Game.generatedPuzzles.length > 0) {
                    document.getElementById('puzzleBadge').innerText = Game.generatedPuzzles.length;
                    document.getElementById('puzzleBadge').classList.remove('d-none');
                }

                bar.style.width = Math.round(((i+1)/moves.length)*50) + "%"; 
                text.innerText = `Analyzing: ${i+1}/${moves.length}`;
            }

            text.innerText = "Consulting Grandmaster Coach...";
            document.getElementById('coachDisplay').innerHTML = '<div class="text-center p-3 text-muted"><i class="fa-solid fa-brain fa-spin me-2"></i> Analyzing threats & variations...</div>';
            bar.className = "progress-bar bg-success progress-bar-striped progress-bar-animated";
            
            await Gemini.getCommentary(Game.analysisData, "Custom Game", focus);
            
            bar.style.width = "100%";
            GUI.renderAnalysisList();

            Game.nav('first'); 
            setTimeout(() => { Game.nav('next'); }, 600);

            GUI.showToast("Analysis Complete", "success");

        } catch(err) {
            console.error(err);
            GUI.showToast("Analysis Failed. Check logs.", "error");
        } finally {
            setTimeout(() => { 
                progressBox.classList.add('d-none'); 
                btn.disabled = false;
                navBtns.forEach(b => b.disabled = false); 
            }, 1000);
        }
    },

    fetchBookData: async function(fen) {
        try { 
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000);
            
            const res = await fetch(`https://explorer.lichess.ovh/masters?fen=${fen}`, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if(res.ok) return await res.json();
        } catch(e){ return null; }
        return null;
    },
    parseEval: function(str) {
        if (typeof str === 'string' && str.startsWith('M')) {
             const moves = parseInt(str.replace('M', ''));
             if (moves === 0) return 100; 
             return moves > 0 ? 10 : -10; 
        }
        return parseFloat(str);
    },
    uciToSan: function(fen, pv) {
        if(!pv) return "";
        const t = new Chess(fen);
        let s = "";
        const mvs = pv.split(' ');
        for(let m of mvs) {
            if(!m) continue;
            const mo = t.move({from:m.substring(0,2), to:m.substring(2,4), promotion: m.length>4?m.substring(4,5):undefined});
            if(mo) s += mo.san + " "; else break;
        }
        return s.trim();
    }
};
window.Scanner = Scanner;

/**
 * PUZZLE MANAGER - Manages Two Separate States
 */
const PuzzleManager = {
    puzzleDepth: 1,
    vsEngine: false,
    
    // State storage for independent tabs
    contexts: {
        smart: { 
            puzzles: [], 
            index: 0, 
            activePuzzle: null,
            plyIndex: 0
        },
        archive: { 
            puzzles: [], 
            index: 0, 
            activePuzzle: null,
            plyIndex: 0
        }
    },
    
    activeContext: 'smart', // 'smart' or 'archive'

    init: function() { 
        this.vsEngine = false; 
        const slider = document.getElementById('puzzleDepthRange');
        if(slider) this.updateDepth(slider.value); 
    },
    
    updateDepth: function(val) {
        this.puzzleDepth = parseInt(val);
        const label = document.getElementById('puzzleDepthLabel');
        if(label) label.innerText = `${this.puzzleDepth} Move${this.puzzleDepth === 1 ? '' : 's'}`;
        // Reset current ply to avoid weird state if depth changes mid-puzzle
        if(this.contexts[this.activeContext]) this.contexts[this.activeContext].plyIndex = 0;
    },

    toggleEngineMode: function() {
        this.vsEngine = document.getElementById('puzzleVsEngine').checked;
        const feedback = document.getElementById('puzzleFeedback');
        if (this.vsEngine) {
            feedback.innerHTML = '<span class="text-primary"><i class="fa-solid fa-robot"></i> Engine Mode: Play any move.</span>';
        } else {
            feedback.innerHTML = '';
            const ctx = this.contexts[this.activeContext];
            if(ctx.activePuzzle) {
                const chess = Game.getActiveChess();
                chess.load(ctx.activePuzzle.fen); 
                GUI.board.position(ctx.activePuzzle.fen);
                ctx.plyIndex = 0;
            }
        }
    },
    
    switchTo: function(contextName) {
        this.activeContext = contextName;
        const ctx = this.contexts[contextName];
        
        // Sync Data Sources
        if (contextName === 'smart') {
            ctx.puzzles = Game.generatedPuzzles;
        } 
        // Archive data is set by ArchiveManager actions, preserved here
        
        this.loadPuzzles();
    },

    loadPuzzles: function() {
        const ctx = this.contexts[this.activeContext];
        ctx.plyIndex = 0;
        
        // Always remove opacity class - never disable board based on empty list
        document.getElementById('boardCard').classList.remove('opacity-50');

        if (ctx.puzzles.length === 0) {
            if (this.activeContext === 'archive') {
                document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted">No archived puzzles available. Return to Archive tab to start.</span>`;
            } else {
                document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted">No smart puzzles loaded. Scan a game first.</span>`;
            }
            return;
        }
        
        document.getElementById('puzzleEngineContainer').classList.remove('d-none');
        // Ensure index is valid
        if(ctx.index >= ctx.puzzles.length) ctx.index = 0;
        this.showPuzzle(ctx.index);
    },

    showPuzzle: function(idx) {
        const ctx = this.contexts[this.activeContext];
        
        if (idx >= ctx.puzzles.length) {
            document.getElementById('puzzleFeedback').innerHTML = `<span class="text-primary fw-bold">Training Complete!</span>`;
            return;
        }
        
        ctx.index = idx;
        ctx.activePuzzle = ctx.puzzles[idx];
        
        // Load into the specific chess instance for this mode
        const chess = Game.getActiveChess();
        chess.load(ctx.activePuzzle.fen);
        
        GUI.board.position(ctx.activePuzzle.fen);
        GUI.board.orientation(ctx.activePuzzle.color === 'w' ? 'white' : 'black');
        GUI.clearArrows();
        GUI.updateMaterial(); 
        
        ctx.plyIndex = 0;
        document.getElementById('puzzleCountBadge').innerText = `Puzzle ${idx + 1}/${ctx.puzzles.length}`;
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-primary fw-bold">Find the ${this.puzzleDepth} move solution.</span>`;
    },

    handleDrop: async function(source, target) {
        if (Game.mode !== 'puzzles' && Game.mode !== 'archive') return 'snapback';
        
        const move = { from: source, to: target, promotion: 'q' };
        const chess = Game.getActiveChess();

        if (this.vsEngine) {
            const result = chess.move(move);
            if (result) {
                GUI.update();
                Engine.analyze(chess.fen());
                if (!chess.game_over()) {
                     setTimeout(async () => {
                        const best = await Engine.getBestMove(chess.fen());
                        if (best) {
                            chess.move({ from: best.substring(0,2), to: best.substring(2,4), promotion: 'q' });
                            GUI.update();
                            Engine.analyze(chess.fen());
                        }
                    }, 500);
                }
                return undefined;
            }
            return 'snapback';
        }

        const valid = await this.validateMove(source, target);
        if (valid) {
            GUI.updateMaterial();
            return undefined;
        } else {
            return 'snapback';
        }
    },

    validateMove: async function(source, target) {
        const ctx = this.contexts[this.activeContext];
        if (!ctx.activePuzzle) return false;
        
        const chess = Game.getActiveChess();
        
        const userUci = source + target; 
        const isFirstMove = (ctx.plyIndex === 0);
        
        // Safety check
        if (chess.turn() !== ctx.activePuzzle.color && !isFirstMove) {
            return false;
        }

        if (isFirstMove) {
            // Validate first move against official solution
            const primarySol = ctx.activePuzzle.solution;
            if (userUci.indexOf(primarySol) === 0) {
                // Correct
            } else {
                // Check if in Top 3 moves
                document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted"><i class="fa-solid fa-spinner fa-spin"></i> Checking alternative...</span>`;
                const topMoves = await Engine.getTopMoves(ctx.activePuzzle.fen, 3);
                const isGood = topMoves.some(m => m.indexOf(userUci) === 0);
                
                if (!isGood) {
                    this.onFail();
                    return false;
                }
            }
        } else {
            document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted"><i class="fa-solid fa-spinner fa-spin"></i> Checking position quality...</span>`;
            const topMoves = await Engine.getTopMoves(chess.fen(), 3);
            const isGood = topMoves.some(m => m.indexOf(userUci) === 0);

            if (!isGood) {
                this.onFail();
                return false;
            }
        }

        const moveResult = chess.move({ from: source, to: target, promotion: 'q' });
        if (!moveResult) return false; 
        
        ctx.plyIndex++;
        
        // 1. Check if SOLVED
        if (Math.ceil(ctx.plyIndex / 2) === this.puzzleDepth) {
             this.onSuccess();
             return true;
        }
        
        // 2. Queue Engine Response
        if (!chess.game_over()) {
            document.getElementById('puzzleFeedback').innerHTML = `<span class="text-info"><i class="fa-solid fa-robot"></i> Opponent thinking...</span>`;
            
            setTimeout(async () => {
                const engineMoveUci = await Engine.getBestMove(chess.fen());
                
                if (engineMoveUci) {
                    chess.move({ from: engineMoveUci.substring(0,2), to: engineMoveUci.substring(2,4), promotion: 'q' });
                    GUI.board.position(chess.fen());
                    GUI.updateMaterial();
                    ctx.plyIndex++;
                    
                    if (chess.game_over()) {
                        this.onSuccess(); 
                    } else {
                        const remainingMoves = this.puzzleDepth - Math.ceil(ctx.plyIndex / 2);
                        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-primary"><i class="fa-solid fa-brain"></i> Your Turn (${remainingMoves} moves left)</span>`;
                    }
                } else {
                    this.onFail();
                }
            }, 500);
        } else {
             this.onSuccess(); 
        }
        
        return true;
    },

    onSuccess: function() {
        document.getElementById('board').classList.add('puzzle-success');
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-correct"><i class="fa-solid fa-check"></i> Correct! Solved in ${this.puzzleDepth} moves!</span>`;
        setTimeout(() => document.getElementById('board').classList.remove('puzzle-success'), 500);
    },

    onFail: function() {
        document.getElementById('board').classList.add('puzzle-fail');
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-incorrect"><i class="fa-solid fa-xmark"></i> Incorrect. Try again.</span>`;
        setTimeout(() => {
            const ctx = this.contexts[this.activeContext];
            document.getElementById('board').classList.remove('puzzle-fail');
            document.getElementById('puzzleFeedback').innerHTML = "";
            if(ctx.activePuzzle && !this.vsEngine) {
                const chess = Game.getActiveChess();
                chess.load(ctx.activePuzzle.fen);
                GUI.board.position(ctx.activePuzzle.fen);
                ctx.plyIndex = 0; 
            }
        }, 1000); 
    },

    next: function() {
        const ctx = this.contexts[this.activeContext];
        if (ctx.index < ctx.puzzles.length - 1) this.showPuzzle(ctx.index + 1);
    },
    
    prev: function() {
        const ctx = this.contexts[this.activeContext];
        if (ctx.index > 0) this.showPuzzle(ctx.index - 1);
    },
    
    skip: function() {
        const ctx = this.contexts[this.activeContext];
        if (ctx.index < ctx.puzzles.length - 1) this.showPuzzle(ctx.index + 1);
    }
};
window.PuzzleManager = PuzzleManager;

/**
 * ARCHIVE MANAGER
 */
const ArchiveManager = {
    startRandom: function() {
        if (Game.puzzleArchive.length === 0) {
            GUI.showToast("Archive is empty!", "error");
            return;
        }
        // Load shuffled archive into the 'archive' context of PuzzleManager
        PuzzleManager.contexts.archive.puzzles = [...Game.puzzleArchive].sort(() => Math.random() - 0.5);
        PuzzleManager.contexts.archive.index = 0;
        
        Game.puzzleSource = 'archive'; // Flag to indicate we are actively playing archive
        GUI.switchTab('archive'); 
    },

    clearArchive: function() {
        if(confirm("Are you sure you want to delete ALL saved puzzles? This action cannot be undone.")) {
            Game.puzzleArchive = [];
            Game.saveArchive();
            this.renderList(); 
            GUI.updateArchiveCount();
            GUI.showToast("Puzzle archive cleared.", "success");
            
            PuzzleManager.contexts.archive.puzzles = [];
            if (Game.puzzleSource === 'archive') {
                Game.puzzleSource = null;
                GUI.switchTab('archive'); // Return to list view
            }
        }
    },

    renderList: function() {
        const infoDiv = document.getElementById('archiveListInfo');
        if(infoDiv) {
            if (Game.puzzleArchive.length === 0) {
                infoDiv.innerHTML = 'Puzzles loaded in the archive are available for random training. (Archive is currently empty)';
            } else {
                 infoDiv.innerHTML = `There are ${Game.puzzleArchive.length} puzzles in the archive. Use "Start Random Puzzle from Archive" to begin training.`;
            }
        }
    }
};
window.ArchiveManager = ArchiveManager;

/**
 * GUI & INTERACTION
 */
const GUI = {
    board: null,
    settingsModal: null,
    hintState: 0, 
    showEvalInPlay: true,
    
    init: function() {
        this.board = Chessboard('board', {
            draggable: true,
            position: 'start',
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
            onDragStart: (src, p) => {
                Game.selectedSquare = null;
                $('.square-55d63').removeClass('highlight-selected');

                if (Game.mode === 'analysis' || (Game.mode === 'play' && Game.playViewIndex !== -1)) return false; 
                
                const chess = Game.getActiveChess();
                const turnColor = chess.turn(); 
                const pieceColor = p.charAt(0); 
                
                if (Game.mode === 'play') {
                    if (pieceColor !== Game.playUserColor || chess.turn() !== Game.playUserColor || chess.game_over()) return false;
                }
                
                // Block if in puzzle mode but trying to move the wrong color
                if ((Game.mode === 'puzzles' || Game.mode === 'archive') && pieceColor !== chess.turn()) return false;
                
                if (turnColor !== pieceColor) return false;
                return true;
            },
            onDrop: async (src, tgt) => {
                if (src === tgt || (Game.mode === 'play' && Game.playViewIndex !== -1)) return 'snapback';

                if (Game.mode === 'puzzles' || Game.mode === 'archive') {
                    return await PuzzleManager.handleDrop(src, tgt);
                } else {
                    const res = Game.move(src, tgt);
                    return res ? undefined : 'snapback';
                }
            }
        });

        // TAP TO MOVE HANDLER
        $('#board').on('click', '.square-55d63', function(e) {
            e.preventDefault();
            const square = $(this).attr('data-square');
            GUI.handleSquareClick(square);
        });

        window.addEventListener('resize', () => {
             this.board.resize();
             if (window.innerWidth <= 768) document.getElementById('sidebar').classList.add('collapsed');
        });
        
        Engine.init();
        PuzzleManager.init();
        this.settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
        
        const k = localStorage.getItem('gemini_api_key');
        if(k) document.getElementById('apiKeyInput').value = k;
        
        this.showEvalInPlay = document.getElementById('showEvalToggle').checked;
        Game.loadFromStorage();
        this.updateEloLabel(5);
        this.updateArchiveCount(); 
        this.setupDragControls(); 

        if (window.innerWidth <= 768) document.getElementById('sidebar').classList.add('collapsed');
    },
    
    setupDragControls: function() {
        const controls = document.getElementById('verticalAnalysisControls');
        let isDragging = false;
        let offset = { x: 0, y: 0 };

        const startDrag = (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return; 
            isDragging = true;
            controls.style.cursor = 'grabbing';
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            const rect = controls.getBoundingClientRect();
            controls.style.left = `${rect.left}px`;
            controls.style.top = `${rect.top}px`;
            controls.style.right = 'auto'; 
            controls.style.bottom = 'auto';
            controls.style.transform = 'none';

            offset = {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        };

        const onDrag = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            let newX = clientX - offset.x;
            let newY = clientY - offset.y;
            
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const controlW = controls.offsetWidth;
            const controlH = controls.offsetHeight;

            newX = Math.max(0, Math.min(newX, viewportW - controlW));
            newY = Math.max(0, Math.min(newY, viewportH - controlH));

            controls.style.left = `${newX}px`;
            controls.style.top = `${newY}px`;
        };

        const endDrag = () => {
            isDragging = false;
            controls.style.cursor = 'grab';
        };

        controls.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', endDrag);

        controls.addEventListener('touchstart', startDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('touchend', endDrag);

        GUI.toggleControlsOrientation = function() {
            controls.classList.toggle('landscape');
            setTimeout(() => { GUI.board.resize(); }, 50);
        };
    },

    handleSquareClick: function(square) {
        if (Game.mode === 'analysis' || (Game.mode === 'play' && Game.playViewIndex !== -1) || Game.getActiveChess().game_over()) return; 

        const chess = Game.getActiveChess();
        const turn = chess.turn();
        const piece = chess.get(square);
        
        if (!Game.selectedSquare) {
            if (piece && piece.color === turn) {
                if (Game.mode === 'play' && (piece.color !== Game.playUserColor || chess.turn() !== Game.playUserColor)) return;
                
                Game.selectedSquare = square;
                $('.square-55d63').removeClass('highlight-selected');
                $('.square-' + square).addClass('highlight-selected');
            }
            return;
        }

        const source = Game.selectedSquare;
        
        if (source === square) {
            Game.selectedSquare = null;
            $('.square-55d63').removeClass('highlight-selected');
            return;
        }

        if (piece && piece.color === turn) {
             if (Game.mode !== 'play' || piece.color === Game.playUserColor) {
                 Game.selectedSquare = square;
                 $('.square-55d63').removeClass('highlight-selected');
                 $('.square-' + square).addClass('highlight-selected');
                 return;
             }
        }

        if (Game.mode === 'puzzles' || Game.mode === 'archive') {
             PuzzleManager.handleDrop(source, square).then(res => {
                 if (res !== 'snapback') GUI.board.position(Game.getActiveChess().fen());
             });
        } else {
            const success = Game.move(source, square);
            if (!success) {
                Game.selectedSquare = null;
                $('.square-55d63').removeClass('highlight-selected');
            } else {
                Game.selectedSquare = null;
                $('.square-55d63').removeClass('highlight-selected');
            }
        }
    },
    
    showToast: function(message, type = 'success') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `custom-toast ${type}`;
        
        let icon = type === 'success' ? '<i class="fa-solid fa-circle-check fa-lg text-success"></i>' : '<i class="fa-solid fa-triangle-exclamation fa-lg text-warning"></i>';
        
        toast.innerHTML = `${icon} <span>${message}</span>`;
        container.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 100);
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    },

    updateEloLabel: function(val) {
        const elo = 800 + (val * 120);
        document.getElementById('eloLabel').innerText = `ELO: ~${elo}`;
    },

    updateArchiveCount: function() {
        const count = Game.puzzleArchive.length;
        document.getElementById('archiveCount').innerText = count;
        document.getElementById('archiveBadge').innerText = count;
        ArchiveManager.renderList(); 
    },

    switchTab: function(mode) {
        Game.mode = mode;
        Engine.stop();
        
        Game.playViewIndex = -1;
        
        this.updateEval(0, null); 
        document.getElementById('wdlValue').innerText = "Win: 50%"; 

        document.querySelectorAll('.mode-tab').forEach(el => el.classList.remove('active'));
        
        const analysisIds = ['analysisControls', 'analysisPanel', 'scanBtn', 'verticalAnalysisControls'];
        const puzzleIds = ['puzzleControls', 'puzzleStatusHeader', 'puzzleFeedback', 'puzzleEngineContainer'];
        const playIds = ['playControls'];
        
        const hideAll = (ids) => ids.forEach(id => document.getElementById(id)?.classList.add('d-none'));
        const showAll = (ids) => ids.forEach(id => document.getElementById(id)?.classList.remove('d-none'));
        
        hideAll(analysisIds); hideAll(puzzleIds); hideAll(playIds);
        document.getElementById('analysisPanel').classList.add('hidden'); 
        document.getElementById('puzzleArchivePanel').classList.add('d-none');
        document.getElementById('boardCard').classList.add('d-none'); 
        document.getElementById('boardCard').classList.remove('opacity-50'); // Ensure board is NEVER disabled
        
        const analysisListContainer = document.getElementById('analysisListContainer');
        const coachDisplay = document.getElementById('coachDisplay');
        const header = document.getElementById('boardHeaderContainer');
        
        if (mode === 'analysis') {
            document.getElementById('tab-analysis').classList.add('active');
            header.classList.add('d-none');
            showAll(['analysisPanel', 'scanBtn', 'verticalAnalysisControls']);
            document.getElementById('analysisPanel').classList.remove('hidden');
            document.getElementById('boardCard').classList.remove('d-none');
            
            analysisListContainer.classList.add('d-none'); 
            coachDisplay.style.flex = '1';
            
            Game.analysisChess.reset();
            for(let i=0; i<=Game.index; i++) {
                 if(Game.history[i]) Game.analysisChess.move(Game.history[i].san);
            }
            this.board.position(Game.analysisChess.fen());
            this.update(); 
            this.board.orientation(Game.userColor === 'b' ? 'black' : 'white');
            document.getElementById('gameTitle').innerText = "Game Analysis";
        } 
        else if (mode === 'puzzles') {
            document.getElementById('tab-puzzles').classList.add('active');
            
            header.classList.remove('d-none'); 
            document.getElementById('boardCard').classList.remove('d-none');
            showAll(puzzleIds);
            
            document.getElementById('gameTitle').innerText = "Smart Puzzles";
            analysisListContainer.classList.remove('d-none');
            coachDisplay.style.flex = 'none';
            
            PuzzleManager.switchTo('smart'); // Switch to Smart Puzzles context
        }
        else if (mode === 'archive') {
            document.getElementById('tab-archive').classList.add('active');
            
            if (Game.puzzleSource === 'archive') {
                // Archive Puzzles are being PLAYED
                header.classList.remove('d-none'); 
                document.getElementById('boardCard').classList.remove('d-none');
                showAll(puzzleIds);
                document.getElementById('gameTitle').innerText = "Archive Puzzles Training";
                
                analysisListContainer.classList.add('d-none'); 
                coachDisplay.style.flex = 'none';
                
                PuzzleManager.switchTo('archive'); // Switch to Archive Puzzles context
            } else {
                // Archive is being BROWSED (static panel mode)
                document.getElementById('puzzleArchivePanel').classList.remove('d-none'); 
                document.getElementById('boardCard').classList.add('d-none'); 
                document.getElementById('gameTitle').innerText = "Puzzle Archive";
                // Reset state
                Game.analysisChess.reset();
            }
        }
        else if (mode === 'play') {
            document.getElementById('tab-play').classList.add('active');
            header.classList.remove('d-none');
            document.getElementById('boardCard').classList.remove('d-none');
            showAll(playIds);
            
            this.board.position(Game.playChess.fen());
            this.update(); 
            this.board.orientation(Game.playUserColor === 'w' ? 'white' : 'black');
            document.getElementById('gameTitle').innerText = "Vs Stockfish";
            analysisListContainer.classList.remove('d-none');
            coachDisplay.style.flex = 'none';
        }
        this.updateMaterial();
        setTimeout(() => this.board.resize(), 100);
    },
    
    toggleSettings: function() { this.settingsModal.show(); },
    toggleLogs: function(show) { document.getElementById('logPanel').classList.toggle('hidden', !show); },
    toggleEvalBar: function(show) { 
        this.showEvalInPlay = show;
        this.updateEvalDisplayVisibility();
    },

    updateEvalDisplayVisibility: function() {
        const container = document.getElementById('boardCard');
        if (Game.mode === 'play' && !this.showEvalInPlay) {
            container.classList.add('play-mode-blind');
        } else {
            container.classList.remove('play-mode-blind');
        }
    },

    toggleSidebar: function() {
        document.getElementById('sidebar').classList.toggle('collapsed');
        setTimeout(() => this.board.resize(), 300);
    },

    // Play Mode Features
    flip: function(mode) {
        if (mode === 'play') {
            Engine.stop();
            
            Game.playUserColor = Game.playUserColor === 'w' ? 'b' : 'w';
            this.board.orientation(Game.playUserColor === 'w' ? 'white' : 'black');
            
            if (Game.playChess.turn() !== Game.playUserColor && !Game.playChess.game_over()) {
                document.getElementById('boardCard').classList.add('opacity-50'); 
                Engine.playResponse(Game.playChess.fen());
            } else {
                 document.getElementById('boardCard').classList.remove('opacity-50'); 
            }
        } else {
            this.board.flip();
        }
        this.clearArrows();
    },

    resetGame: function() {
        if(confirm("Start new game?")) {
            Game.playChess.reset();
            Game.playUserColor = 'w';
            Game.playViewIndex = -1;
            this.board.orientation('white');
            document.getElementById('checkmateOverlay').classList.add('d-none');
            document.getElementById('boardCard').classList.remove('opacity-50'); 
            GUI.update();
            Engine.analyze(Game.playChess.fen());
        }
    },

    undoPlayMove: function() {
        Game.playChess.undo(); 
        Game.playChess.undo(); 
        Game.playViewIndex = -1;
        document.getElementById('boardCard').classList.remove('opacity-50');
        GUI.update();
        Engine.analyze(Game.playChess.fen());
    },

    update: function() {
        const chess = Game.getActiveChess(); 
        this.board.position(chess.fen());
        this.resetHint();
        this.clearArrows();
        this.updateMaterial();
        this.updateEvalDisplayVisibility(); 
        
        if (Game.mode === 'puzzles' || Game.mode === 'archive' || Game.mode === 'play') {
            if(Game.mode === 'play' && Game.playViewIndex === -1) {
                 Engine.analyze(Game.playChess.fen()); 
            }
            return;
        }

        // ANALYSIS UPDATE
        const moveIdx = Game.index; 
        const ply = moveIdx + 1; 

        const display = document.getElementById('coachDisplay');
        let commentData = Gemini.comments[ply.toString()];
        const analysisItem = Game.analysisData[moveIdx];
        
        display.className = "coach-display"; 
        if(analysisItem) display.classList.add(analysisItem.classification);

        if (commentData) {
            let html = `<div><strong>${analysisItem.classification}</strong>. ${marked.parse(commentData.analysis)}</div>`;
            if (commentData.pv_explanation && commentData.pv_explanation.length > 0) {
                html += `<div class="mt-2 text-muted small border-top pt-2"><strong><i class="fa-solid fa-list-ol"></i> Plan:</strong><ul>`;
                commentData.pv_explanation.forEach(line => html += `<li>${line}</li>`);
                html += `</ul></div>`;
            }
            display.innerHTML = html;
        } else if (analysisItem) {
             display.innerHTML = `<div><strong>${analysisItem.classification}</strong>. ${analysisItem.bestMoveSan ? `Missed <span class="badge bg-success">${analysisItem.bestMoveSan}</span>.` : ''}</div>
             <div class="mt-3 text-muted small"><i class="fa-solid fa-microchip"></i> Engine Best: ${analysisItem.bestMoveSan}</div>
             `;
        }
    },
    
    updateMaterial: function() {
        const chess = Game.mode === 'puzzles' || Game.mode === 'archive' ? Game.analysisChess : Game.getActiveChess();
        const board = chess.board();
        
        const fullSet = { p:8, n:2, b:2, r:2, q:1, k:1 };
        let currentCounts = { w: {p:0,n:0,b:0,r:0,q:0,k:0}, b: {p:0,n:0,b:0,r:0,q:0,k:0} };
        
        for(let r=0; r<8; r++){
            for(let c=0; c<8; c++){
                const p = board[r][c];
                if(p) currentCounts[p.color][p.type]++;
            }
        }
        
        const icons = { p: '', n: '', b: '', r: '', q: '', k: '' }; 
        const getGraveyard = (colorOfPiecesCaptured) => {
            let s = "";
            ['q','r','b','n','p'].forEach(type => {
                let capturedCount = fullSet[type] - currentCounts[colorOfPiecesCaptured][type];
                if(capturedCount > 0) {
                    for(let i=0; i<capturedCount; i++) s += `<span class="ms-1">${icons[type]}</span>`;
                }
            });
            return s;
        }
        
        document.getElementById('matWhite').innerHTML = getGraveyard('b');
        document.getElementById('matBlack').innerHTML = getGraveyard('w');
    },

    resetCoachDisplay: function() {
        document.getElementById('coachDisplay').innerHTML = `<div class="text-center text-muted" style="margin-top:20px"><i class="fa-solid fa-chess"></i><br>Ready.</div>`;
    },
    
    updateEval: function(cp, mate) {
        let valText = "0.00";
        let pct = 50;
        let winPct = 50;
        
        if (mate !== null) {
            valText = `M${Math.abs(mate)}`;
            pct = mate > 0 ? 100 : 0;
            winPct = mate > 0 ? 100 : 0;
        } else {
            valText = (cp / 100).toFixed(2);
            if(cp > 0) valText = "+" + valText;
            let val = Math.max(-500, Math.min(500, cp));
            pct = 50 + (val / 10);
            winPct = 50 + (50 * (2 / (1 + Math.exp(-0.004 * cp)) - 1));
        }
        
        document.getElementById('evalValue').innerText = valText;
        document.getElementById('evalFill').style.width = pct + '%';
        document.getElementById('wdlValue').innerText = `Win: ${Math.round(winPct)}%`;
    },

    renderAnalysisList: function() {
        const list = document.getElementById('analysisList');
        list.innerHTML = "";
        Game.analysisData.forEach((d, i) => {
            const div = document.createElement('div');
            div.className = 'log-entry';
            div.id = `log-${i}`;
            div.onclick = () => {
                Game.analysisChess.reset();
                for(let k=0; k<=i; k++) Game.analysisChess.move(Game.history[k].san);
                Game.index = i;
                GUI.update();
                Engine.analyze(Game.analysisChess.fen());
                GUI.clearArrows();
            };
            const moveNum = Math.ceil((i + 1) / 2) + (d.color === 'w' ? '.' : '...');
            
            div.innerHTML = `
                <div class="d-flex align-items-center">
                    <span class="text-muted small me-2" style="width:25px">${moveNum}</span> 
                    <strong>${d.san}</strong>
                </div>
                <div class="d-flex align-items-center gap-1">
                    <span class="small text-muted">${d.eval}</span>
                    <span class="move-class class-${d.classification}">${d.classification}</span>
                </div>`;
            list.appendChild(div);
        });
    },
    
    hint: async function() {
        const fen = Game.getActiveChess().fen();
        const best = await Engine.getBestMove(fen);
        if(!best) return;
        const from = best.substring(0,2);
        const to = best.substring(2,4);

        if (this.hintState === 0) {
            $('.square-55d63').removeClass('highlight-hint');
            $('.square-' + from).addClass('highlight-hint');
            this.hintState = 1;
        } else {
            this.drawArrow(from, to, '#22c55e');
            this.hintState = 0;
        }
    },
    
    showBestMove: async function() {
        const fen = Game.getActiveChess().fen();
        const best = await Engine.getBestMove(fen);
        if(!best) return;
        const from = best.substring(0,2);
        const to = best.substring(2,4);
        
        this.clearArrows();
        this.drawArrow(from, to, '#22c55e');
        
        $('.square-' + from).addClass('highlight-hint');
        setTimeout(() => $('.square-' + from).removeClass('highlight-hint'), 1500);
    },
    
    resetHint: function() {
        this.hintState = 0;
        $('.square-55d63').removeClass('highlight-hint');
    },
    
    drawArrow: function(from, to, color) {
        const $board = $('#board');
        const boardWidth = $board.width();
        const sqSize = boardWidth / 8;
        const orientation = this.board.orientation();
        const cols = 'abcdefgh';
        const rows = '87654321';
        const getCoords = (sq) => {
            let c = cols.indexOf(sq[0]);
            let r = rows.indexOf(sq[1]);
            if (orientation === 'black') { c = 7 - c; r = 7 - r; }
            return { x: c * sqSize + sqSize/2, y: r * sqSize + sqSize/2 };
        }
        const start = getCoords(from);
        const end = getCoords(to);
        const svg = document.getElementById('arrowOverlay');
        const id = `arrow-${from}-${to}`;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', start.x);
        line.setAttribute('y1', start.y);
        line.setAttribute('x2', end.x);
        line.setAttribute('y2', end.y);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', sqSize * 0.15);
        line.setAttribute('opacity', '0.7');
        line.setAttribute('marker-end', `url(#head-${id})`);
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', `head-${id}`);
        marker.setAttribute('markerWidth', '4');
        marker.setAttribute('markerHeight', '4');
        marker.setAttribute('refX', '2');
        marker.setAttribute('refY', '2');
        marker.setAttribute('orient', 'auto');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M0,0 L4,2 L0,4 Z');
        path.setAttribute('fill', color);
        marker.appendChild(path);
        defs.appendChild(marker);
        svg.appendChild(defs);
        svg.appendChild(line);
    },
    
    clearArrows: function() {
        const svg = document.getElementById('arrowOverlay');
        while(svg.lastChild) svg.removeChild(svg.lastChild);
    },
    
    next: () => Game.nav('next'), prev: () => Game.nav('prev'), first: () => Game.nav('first'), last: () => Game.nav('last'),
    
    copyPGN: function() {
        const pgn = Game.getActiveChess().pgn();
        const ta = document.createElement('textarea');
        ta.value = pgn;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("PGN copied!", "success");
    },

    copyLogs: function() {
        if (!window.sys_logs || window.sys_logs.length === 0) {
            GUI.showToast("No logs to copy.", "error");
            return;
        }
        let logText = window.sys_logs.map(l => 
            `[${l.timestamp}] [${l.type}] ${l.message}`
        ).join('\n');
        
        const ta = document.createElement('textarea');
        ta.value = logText;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("System logs copied to clipboard.", "success");
    },
    
    copyAnalysis: function() {
        if (!Game.analysisData || Game.analysisData.length === 0) { GUI.showToast("No analysis available.", "error"); return; }
        let report = `Game Analysis\n\n`;
        Game.analysisData.forEach((d, i) => {
            report += `${i+1}. ${d.san} [${d.classification}] ${d.eval}\n`;
            if(Gemini.comments[i+1]) report += `Coach: ${Gemini.comments[i+1].analysis}\n`;
        });
        const ta = document.createElement('textarea');
        ta.value = report;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("Analysis copied!", "success");
    }
};
window.GUI = GUI;

function importManualPGN() {
    const pgn = document.getElementById('pgnText').value;
    if(!pgn) return;
    const newGame = { id: Date.now(), date: '-', opening: "Custom PGN", result: '?', accuracy: 0, pgn: pgn, oppRating: '?', userColor: 'white' };
    Game.data.unshift(newGame);
    Game.save();
    renderList();
    document.getElementById('pgnModal').style.display='none';
    document.getElementById('pgnModal').classList.remove('show');
    Game.load(newGame.id);
}
document.getElementById('csvInput').onchange = (e) => { if(e.target.files.length) parseFile(e.target.files[0]); };
function parseFile(file) {
    Papa.parse(file, { header: true, skipEmptyLines: true, complete: (res) => {
        const newData = res.data.map((r, i) => ({
            id: i, date: r.date || '-', opening: r.opening || 'Unknown',
            result: r.result || '-', accuracy: parseFloat(r.userAccuracy) || 0,
            pgn: r.pgn || "", oppRating: parseInt(r.opponentRating) || 0,
            userColor: (r.userColor || 'white').toLowerCase()
        }));
        const baseId = Date.now();
        newData.forEach((game, index) => game.id = baseId + index);

        Game.data = [...newData, ...Game.data];
        Game.save();
        renderList();
    }});
}
function renderList() {
    const list = document.getElementById('gameList'); list.innerHTML = "";
    let arr = [...Game.data];
    const sort = document.getElementById('sortSelect').value;
    
    if(sort === 'recent') arr.sort((a,b) => b.id - a.id);
    else if(sort === 'oldest') arr.sort((a,b) => a.id - b.id);
    else if(sort === 'acc_high') arr.sort((a,b) => b.accuracy - a.accuracy);
    else if(sort === 'acc_low') arr.sort((a,b) => a.accuracy - b.accuracy);
    else if(sort === 'elo_high') arr.sort((a,b) => b.oppRating - a.oppRating);
    else if(sort === 'elo_low') arr.sort((a,b) => a.oppRating - b.oppRating);

    arr.forEach(g => {
        const div = document.createElement('div'); div.className = "game-item"; div.id = "g-" + g.id;
        div.onclick = () => Game.load(g.id); 
        div.innerHTML = `<div class="d-flex justify-content-between fw-bold"><span class="text-truncate" style="max-width:180px">${g.opening}</span><span class="${g.result==='win'?'text-success':(g.result==='loss'?'text-danger':'text-muted')}">${g.result}</span></div><div class="game-meta">Acc: ${g.accuracy}%  Vs ${g.oppRating}</div>`;
        list.appendChild(div);
    });
}
window.onload = function() { 
    try {
        if(typeof GUI !== 'undefined' && GUI.init) {
            setTimeout(() => {
                GUI.init();
                GUI.switchTab('analysis');
            }, 100);
        } else {
            console.error("GUI not loaded");
        }
    } catch(e) { console.error("Init failed", e); }
};
</script>
</body>
</html>
