<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Arena: Grandmaster Coach</title>
    
    <!-- Dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- CSS -->
    <style>
        /*! chessboard.js v1.0.0 | (c) 2019 Chris Oakman | MIT License chessboardjs.com/license */
        .clearfix-7da63 { clear: both; }
        .board-b72b1 { border: 2px solid #404040; box-sizing: content-box; }
        .board-b72b1 * { box-sizing: content-box; }
        .square-55d63 { float: left; position: relative; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; outline: 1px solid rgba(0,0,0,0.15); outline-offset: -1px; }
        .square-55d63:after, .square-55d63:before { display: table; content: " "; }
        .square-55d63:after { clear: both; }
        .piece-417db { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: pointer; z-index: 50; } 
        .alpha-d2270 { position: absolute; bottom: 1px; right: 3px; font-size: 11px; line-height: 12px; }
        .numeric-fc462 { position: absolute; top: 2px; left: 2px; font-size: 11px; cursor: default; line-height: 12px; }
        
        /* App Styles - Permanent Light Mode */
        body { background-color: #f1f5f9; font-family: 'Inter', system-ui, sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; color: #1e1b4b; }
        .navbar { background: #1e1b4b; color: white; padding: 0.5rem 1rem; border-bottom: 1px solid #334155; flex-shrink: 0; z-index: 20; }
        .navbar-brand { color: white; font-weight: 700; font-size: 1.1rem; text-decoration: none; display: flex; align-items: center; gap: 10px; }
        .main-layout { display: flex; flex: 1; overflow: hidden; position: relative; }
        
        .sidebar { width: 320px; background: white; border-right: 1px solid #cbd5e1; display: flex; flex-direction: column; z-index: 10; flex-shrink: 0; transition: margin-left 0.3s ease; }
        .sidebar.collapsed { margin-left: -320px; }
        .sidebar-header { padding: 15px; border-bottom: 1px solid #e2e8f0; background: #f8fafc; display: flex; flex-direction: column; gap: 10px; }
        .game-list, .puzzle-archive-list { flex: 1; overflow-y: auto; background: white;}
        .game-item, .puzzle-item { padding: 10px 15px; border-bottom: 1px solid #f1f5f9; cursor: pointer; transition: background 0.1s; font-size: 0.9rem; }
        .game-item:hover, .puzzle-item:hover { background: #f1f5f9; }
        .game-item.active, .puzzle-item.active { background: #e0e7ff; border-left: 3px solid #4f46e5; }
        
        .content-area { flex: 1; display: flex; flex-direction: column; min-width: 0; background: #f8fafc; height: 100%; position: relative; }
        
        .mode-tabs { padding: 10px 10px 0 10px; background: #fff; border-bottom: 1px solid #cbd5e1; display: flex; gap: 5px; flex-shrink: 0; }
        .mode-tab { padding: 8px 16px; cursor: pointer; border-radius: 6px 6px 0 0; font-weight: 600; font-size: 0.9rem; color: #64748b; border: 1px solid transparent; border-bottom: none; display: flex; align-items: center; gap: 6px; }
        .mode-tab:hover { background: #f8fafc; color: #334155; }
        .mode-tab.active { background: #f8fafc; color: #1e1b4b; border-color: #cbd5e1; border-bottom: 1px solid #f8fafc; margin-bottom: -1px; z-index: 2; }
        
        /* DESKTOP LAYOUT */
        .arena { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 20px 80px 20px 20px; overflow-y: auto; position: relative; min-height: 0; }
        .board-card { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); width: 100%; max-width: 560px; display: flex; flex-direction: column; gap: 10px; position: relative; transition: all 0.3s; z-index: 5; }
        
        /* Board Wrapper */
        #board-wrapper { position: relative; width: 100%; }
        #board { width: 100%; height: 100%; touch-action: none; z-index: 10; position: relative; }
        #arrowOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        /* Analysis Panel */
        .analysis-panel { 
            flex: 0 0 35vh; 
            min-height: 150px;
            max-height: 50vh;
            background: white; 
            border-top: 1px solid #cbd5e1; 
            display: flex; 
            flex-direction: row; 
            flex-shrink: 0; 
            transition: all 0.3s ease;
            position: relative;
            z-index: 20;
        }
        .analysis-moves { 
            flex: 1; border-right: 1px solid #eee; display: flex; flex-direction: column; position: relative; 
            min-height: 0; 
        }
        .analysis-logs { width: 40%; display: flex; flex-direction: column; background: #0f172a; color: #4ade80; font-family: monospace; font-size: 11px; transition: width 0.3s; }
        .analysis-logs.hidden { display: none !important; }
        .analysis-panel.hidden { display: none !important; }
        
        /* HIDE MOVE LIST */
        #analysisListContainer { display: none !important; }

        .move-class { font-size: 0.65rem; font-weight: 800; padding: 2px 6px; border-radius: 4px; color: white; text-transform: uppercase; letter-spacing: 0.5px; }
        .class-Brilliant { background-color: #1baca6; } .class-Great { background-color: #5c8bb0; } .class-Best { background-color: #96bc4b; } 
        .class-Excellent { background-color: #96bc4b; opacity: 0.8; } .class-Good { background-color: #96bc4b; opacity: 0.6; } 
        .class-Book { background-color: #d5a47d; } .class-Inaccuracy { background-color: #f0c15c; color: #5e4b1e; } 
        .class-Mistake { background-color: #e6912c; } .class-Blunder { background-color: #fa412d; } .class-Missed { background-color: #ff879c; } 
        .class-Neutral { background-color: #a3a3a3; } 

        .coach-display { padding: 15px; background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); border-bottom: 1px solid #e2e8f0; font-size: 0.95rem; color: #334155; min-height: 0; flex: 1; overflow-y: auto; position: relative; border-left: 4px solid #cbd5e1; }
        .coach-display.Brilliant { border-left-color: #1baca6; background: #e0f2f1; } .coach-display.Great { border-left-color: #5c8bb0; background: #e1f5fe; }
        .coach-display.Best { border-left-color: #96bc4b; background: #f1f8e9; } .coach-display.Excellent { border-left-color: #96bc4b; background: #f1f8e9; }
        .coach-display.Good { border-left-color: #96bc4b; background: #f9fbe7; } .coach-display.Book { border-left-color: #d5a47d; background: #fff3e0; }
        .coach-display.Inaccuracy { border-left-color: #f0c15c; background: #fffde7; } .coach-display.Mistake { border-left-color: #e6912c; background: #fff3e0; }
        .coach-display.Blunder { border-left-color: #fa412d; background: #ffebee; } .coach-display.Missed { border-left-color: #ff879c; background: #fce4ec; }

        .control-row { display: flex; justify-content: center; gap: 5px; margin-top: 5px; }
        .eval-bar-wrapper { width: 100%; height: 8px; background: #475569; border-radius: 4px; overflow: hidden; margin: 5px 0; transition: opacity 0.3s; position: relative; }
        .eval-fill { height: 100%; width: 50%; background: #22c55e; transition: width 0.3s ease-out; }
        .eval-container { transition: opacity 0.3s; }
        .play-mode-blind .eval-container { opacity: 0; pointer-events: none; }
        .material-stats { font-size: 0.9rem; font-weight: 600; color: #475569; display: flex; justify-content: space-between; padding: 6px 10px; background: #f8fafc; border-radius: 4px; margin-top: 5px; border: 1px solid #e2e8f0; }
        .mat-side { display: flex; gap: 2px; align-items: center; min-height: 20px; }
        .mat-label { font-size: 0.7em; text-transform: uppercase; color: #94a3b8; margin-right: 5px; }
        .graveyard-w { color: #000; font-size: 1.2em; display:flex; } .graveyard-b { color: #fff; text-shadow: 0 0 1px #000; font-size: 1.2em; display:flex; } 
        .puzzle-feedback { text-align: center; height: 30px; font-weight: bold; margin-top: 10px; }
        .text-correct { color: #16a34a; } .text-incorrect { color: #dc2626; }
        .puzzle-success { animation: pulse-green 1s; box-shadow: 0 0 15px #22c55e; } .puzzle-fail { animation: shake 0.5s; box-shadow: 0 0 15px #ef4444; }
        .highlight-select { box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.5); }
        .highlight-hint { box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.8) !important; background: rgba(255, 255, 0, 0.2); }
        .highlight-selected { box-shadow: inset 0 0 0 4px rgba(59, 130, 246, 0.8) !important; }
        .opacity-50 { opacity: 0.5; pointer-events: none; }
        .wdl-stats { font-size: 0.7rem; color: #64748b; text-align: center; margin-top: 2px; font-family: monospace; }
        
        /* Draggable Controls (Floating Bar) */
        #verticalAnalysisControls {
            position: fixed; 
            
            /* Default Portrait Layout */
            display: flex; flex-direction: column; gap: 10px; 
            z-index: 2000;
            background: rgba(255, 255, 255, 0.95); padding: 10px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border: 1px solid #cbd5e1;
            cursor: grab;
        }

        /* Landscape Orientation */
        #verticalAnalysisControls.landscape {
            flex-direction: row;
        }
        #verticalAnalysisControls.landscape button {
            margin: 0;
        }

        #verticalAnalysisControls button {
            width: 42px; height: 42px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.2s;
            border: 1px solid #e2e8f0; background: white; color: #334155;
        }
        #verticalAnalysisControls button:hover { background: #f1f5f9; transform: scale(1.05); color: #0f172a; }
        #verticalAnalysisControls button:active { transform: scale(0.95); }
        #verticalAnalysisControls button:disabled { opacity: 0.5; cursor: not-allowed; background: #e2e8f0; }

        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        .checkmate-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 60; display: flex;
            justify-content: center; align-items: center; border-radius: 8px; pointer-events: none;
        }
        .checkmate-text {
            color: #ef4444; font-size: 3rem; font-weight: 900; text-transform: uppercase; text-shadow: 2px 2px 0 #fff; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* TOAST NOTIFICATION */
        .toast-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 9999; }
        .custom-toast {
            background: #334155; color: white; padding: 12px 24px; border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            display: flex; align-items: center; gap: 10px; font-weight: 500; opacity: 0; transform: translateY(20px); transition: all 0.3s ease;
        }
        .custom-toast.show { opacity: 1; transform: translateY(0); }
        .custom-toast.success { background: #065f46; }
        .custom-toast.error { background: #991b1b; }

        /* MOBILE OPTIMIZATION (Pro Analysis Fix) */
        @media (max-width: 768px) {
            .sidebar { position: absolute; height: 100%; box-shadow: 5px 0 15px rgba(0,0,0,0.2); }
            .sidebar.collapsed { margin-left: -320px; }
            
            /* CONTENT AREA: Stack board and analysis vertically */
            .content-area { flex-direction: column; }
            
            /* ARENA: Board + Material + Controls - takes minimum vertical space */
            .arena { 
                padding: 5px 5px 10px 5px !important; 
                flex: 0 0 auto; 
                height: auto;
            }
            .board-card { 
                width: 100% !important; 
                max-width: 100%; 
                padding: 5px;
            }
            #board-wrapper {
                max-width: 95vw;
                aspect-ratio: 1 / 1;
                margin: 0 auto;
            }
            
            /* ANALYSIS PANEL: Coach Display - takes remaining height */
            .analysis-panel { 
                flex: 1; 
                min-height: 100px;
                max-height: initial; 
                border-top: 1px solid #cbd5e1;
                flex-direction: column;
            }
            .analysis-moves {
                flex: 1;
                border-right: none;
            }
            .coach-display {
                flex: 1; 
                min-height: 100px;
                max-height: initial;
            }
            .analysis-logs { display: none !important; }
            
            /* Shrink controls on mobile */
            #verticalAnalysisControls { scale: 0.9; }
        }
    </style>
</head>
<body>

<!-- Navbar -->
<nav class="navbar d-flex justify-content-between align-items-center">
    <div class="d-flex align-items-center gap-3">
        <a class="navbar-brand" href="#"><i class="fa-solid fa-chess-knight fa-lg"></i> Chess Arena Pro</a>
        <span class="badge bg-secondary" id="engineStatus">Engine: Init...</span>
    </div>
    <div class="d-flex gap-2">
        <span class="badge bg-info text-dark" id="dataProfileBadge">Profile: Loading...</span>

        <button class="btn btn-sm btn-outline-light" onclick="GUI.toggleSettings()">
            <i class="fa-solid fa-gear"></i>
        </button>
        <button class="btn btn-sm btn-outline-light" onclick="document.getElementById('pgnModal').classList.add('show'); document.getElementById('pgnModal').style.display='block'">
            <i class="fa-solid fa-file-import"></i> Paste PGN
        </button>
        <input type="file" id="csvInput" accept=".csv" class="d-none">
        <button class="btn btn-sm btn-primary" onclick="document.getElementById('csvInput').click()">
            <i class="fa-solid fa-upload me-1"></i> Upload CSV
        </button>
        <button class="btn btn-sm btn-secondary" onclick="GUI.toggleSidebar()" title="Toggle Games List">
            <i class="fa-solid fa-bars"></i>
        </button>
    </div>
</nav>

<div class="main-layout">
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <input type="text" id="searchBox" class="form-control form-control-sm" placeholder="Search opening..." oninput="renderList()">
            <div class="d-flex gap-1">
                <select class="form-select form-select-sm" id="sortSelect" onchange="renderList()">
                    <option value="recent">Recent</option>
                    <option value="oldest">Oldest</option>
                    <option value="acc_high">Accuracy (High)</option>
                    <option value="acc_low">Accuracy (Low)</option>
                    <option value="elo_high">Opp. ELO (High)</option>
                    <option value="elo_low">Opp. ELO (Low)</option>
                </select>
            </div>
        </div>
        <div class="game-list" id="gameList">
            <div class="p-3 text-center text-muted small">Upload CSV or PGN to load games</div>
        </div>
    </div>

    <div class="content-area">
        <div class="mode-tabs">
            <div class="mode-tab active" id="tab-analysis" onclick="GUI.switchTab('analysis')">
                <i class="fa-solid fa-magnifying-glass me-1"></i> Pro Analysis
            </div>
            <div class="mode-tab" id="tab-puzzles" onclick="GUI.switchTab('puzzles')">
                <i class="fa-solid fa-puzzle-piece me-1"></i> Smart Puzzles <span id="puzzleBadge" class="badge bg-danger rounded-pill ms-1 d-none">0</span>
            </div>
             <div class="mode-tab" id="tab-archive" onclick="GUI.switchTab('archive')">
                <i class="fa-solid fa-box-archive me-1"></i> Puzzle Archive <span id="archiveBadge" class="badge bg-primary rounded-pill ms-1 d-none">0</span>
            </div>
            <div class="mode-tab" id="tab-play" onclick="GUI.switchTab('play')">
                <i class="fa-solid fa-robot me-1"></i> Computer Play
            </div>
        </div>
        
        <!-- Draggable Controls (Fixed positioned, initialized via JS) -->
        <div id="verticalAnalysisControls" class="d-none">
            <button onclick="GUI.first()" title="First Move"><i class="fa-solid fa-backward-step"></i></button>
            <button onclick="GUI.prev()" title="Previous Move"><i class="fa-solid fa-chevron-left"></i></button>
            <button onclick="GUI.next()" title="Next Move"><i class="fa-solid fa-chevron-right"></i></button>
            <button onclick="GUI.last()" title="Last Move"><i class="fa-solid fa-forward-step"></i></button>
            <div style="height: 1px; background: #e2e8f0; margin: 2px 5px;"></div>
            <button onclick="GUI.showBestMove()" title="Show Best Move" class="text-primary"><i class="fa-solid fa-star"></i></button>
            <button onclick="GUI.flip()" title="Flip Board"><i class="fa-solid fa-retweet"></i></button>
            <!-- Orientation Toggle is injected here by JS -->
        </div>

        <div class="arena">
            <div class="board-card" id="boardCard">
                
                <!-- PUZZLE ARCHIVE PANEL -->
                <div id="puzzleArchivePanel" class="d-none w-100 h-100" style="height: 450px !important;">
                    <div class="sidebar-header d-flex justify-content-between align-items-center bg-light">
                        <strong>Archived Puzzles</strong>
                        <button class="btn btn-sm btn-success" onclick="PuzzleArchive.randomize()">
                            <i class="fa-solid fa-dice me-1"></i> Random Puzzle
                        </button>
                    </div>
                    <div class="puzzle-archive-list" id="puzzleArchiveList">
                         <div class="p-3 text-center text-muted small">Loading archive...</div>
                    </div>
                </div>

                <!-- MAIN BOARD PANEL -->
                <div id="mainBoardPanel">
                     <div class="d-flex justify-content-between align-items-center mb-2" id="boardHeaderContainer">
                        <div id="boardHeaderLeft">
                            <strong id="gameTitle" class="text-truncate d-block" style="max-width: 250px;">Practice Board</strong>
                        </div>
                        <div id="puzzleStatusHeader" class="d-none flex-grow-1 text-center">
                            <span class="badge bg-warning text-dark" id="puzzleCountBadge">Puzzle 0/0</span>
                        </div>
                        <div class="d-flex align-items-center gap-2" id="boardHeaderRight">
                            <div class="form-check form-switch m-0 d-none" id="puzzleEngineContainer">
                                <input class="form-check-input" type="checkbox" id="puzzleVsEngine" onchange="PuzzleManager.toggleEngineMode()">
                                <label class="form-check-label small fw-bold" for="puzzleVsEngine">Vs Engine</label>
                            </div>
                        </div>
                    </div>

                    <div id="board-wrapper">
                        <div id="board"></div>
                        <svg id="arrowOverlay"></svg>
                        <div id="checkmateOverlay" class="checkmate-overlay d-none">
                            <div class="checkmate-text">CHECKMATE</div>
                        </div>
                    </div>
                    
                    <div id="evalContainer" class="eval-container">
                        <div class="eval-bar-wrapper" id="evalBar">
                            <div class="eval-fill" id="evalFill"></div>
                        </div>
                        <div class="d-flex justify-content-between small text-muted px-1" id="evalTextContainer">
                            <span id="evalValue">0.00</span>
                            <span id="wdlValue" class="wdl-stats">Win: 50%</span>
                        </div>
                    </div>
                    
                    <div class="material-stats" id="materialDisplay">
                        <div class="mat-side"><span class="mat-label">W Captured:</span><div class="graveyard-w" id="matWhite"></div></div>
                        <div class="mat-side"><span class="mat-label">B Captured:</span><div class="graveyard-b" id="matBlack"></div></div>
                    </div>

                    <div id="puzzleFeedback" class="puzzle-feedback d-none"></div>

                    <!-- Analysis Controls (Hidden but ID needed for logic) -->
                    <div id="analysisControls" class="d-none"><div class="control-row"></div></div>

                    <div id="puzzleControls" class="d-none">
                        <div class="control-row">
                            <button class="btn btn-sm btn-outline-secondary w-25" onclick="PuzzleManager.prev()" title="Previous Puzzle"><i class="fa-solid fa-chevron-left"></i></button>
                            <button class="btn btn-sm btn-secondary w-50" onclick="PuzzleManager.skip()">Skip</button>
                            <button class="btn btn-sm btn-outline-secondary w-25" onclick="PuzzleManager.next()" title="Next Puzzle"><i class="fa-solid fa-chevron-right"></i></button>
                        </div>
                        <div class="control-row mt-2">
                             <button class="btn btn-sm btn-success w-100" onclick="GUI.hint()"><i class="fa-solid fa-lightbulb"></i> Hint</button>
                        </div>
                    </div>

                    <div id="playControls" class="d-none">
                         <div class="control-row">
                            <button class="btn btn-sm btn-outline-secondary" onclick="GUI.prev()"><i class="fa-solid fa-chevron-left"></i></button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="GUI.next()"><i class="fa-solid fa-chevron-right"></i></button>
                            <button class="btn btn-sm btn-dark" onclick="GUI.flip('play')"><i class="fa-solid fa-retweet"></i> Flip Side</button>
                        </div>
                        <div class="control-row">
                             <button class="btn btn-sm btn-warning w-50" onclick="GUI.undoPlayMove()"><i class="fa-solid fa-rotate-left"></i> Undo</button>
                             <button class="btn btn-sm btn-danger w-50" onclick="GUI.resetGame()"><i class="fa-solid fa-trash-can"></i> Reset</button>
                        </div>
                          <div class="control-row">
                             <button class="btn btn-sm btn-outline-secondary w-100" onclick="GUI.copyPGN()"><i class="fa-solid fa-copy"></i> PGN</button>
                        </div>
                        <div class="mt-3 pt-2 border-top">
                            <div class="d-flex justify-content-between">
                                <label class="small fw-bold text-muted">Stockfish Strength</label>
                                <span class="badge bg-primary" id="eloLabel">ELO: 1200</span>
                            </div>
                            <input type="range" class="form-range" min="0" max="20" value="5" id="skillRange" oninput="GUI.updateEloLabel(this.value); Engine.setSkill(this.value)">
                        </div>
                    </div>
                </div> <!-- End Main Board Panel -->

            </div>
        </div>

        <div class="analysis-panel" id="analysisPanel">
            <div class="analysis-moves">
                <div class="sidebar-header d-flex justify-content-between align-items-center bg-light">
                    <strong>Analysis Report</strong>
                    <div class="d-flex gap-1">
                        <select id="analysisFocus" class="form-select form-select-sm" style="width: 80px;">
                            <option value="both">Both</option>
                            <option value="w">White</option>
                            <option value="b">Black</option>
                        </select>
                        <button class="btn btn-sm btn-outline-dark" onclick="GUI.copyAnalysis()" title="Copy Full Analysis">
                             <i class="fa-solid fa-copy"></i>
                        </button>
                        <button class="btn btn-sm btn-primary" id="scanBtn" onclick="Scanner.start()">
                            <i class="fa-solid fa-wand-magic-sparkles me-1"></i> Full Analysis
                        </button>
                    </div>
                </div>
                
                <!-- RELATIVE POSITION PROGRESS BAR -->
                <div class="p-2 bg-light border-bottom d-none" id="scanProgress">
                    <div class="progress" style="height: 5px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" id="scanBar" style="width: 0%"></div>
                    </div>
                    <div class="text-center small text-muted mt-1" id="scanText">Analyzing...</div>
                </div>

                <div class="coach-display" id="coachDisplay">
                    <div class="text-center text-muted" style="margin-top: 20px;">
                        <i class="fa-solid fa-user-graduate fa-2x mb-2"></i><br>
                        Ready for analysis. Press "Full Analysis" to get insights.
                    </div>
                </div>

                <!-- REMOVED: analysisListContainer -->
                <div id="analysisListContainer" style="display: none;">
                    <div class="log-container" id="analysisList"></div>
                </div>
            </div>
            
            <div class="analysis-logs hidden" id="logPanel">
                <!-- Log Panel Header with Copy Button -->
                <div class="p-2 border-bottom border-secondary bg-dark text-white small d-flex justify-content-between align-items-center">
                    <strong>System Log</strong>
                    <button class="btn btn-sm btn-outline-light" style="font-size: 0.7rem; padding: 1px 5px;" onclick="GUI.copyLogs()" title="Copy Logs">
                        <i class="fa-solid fa-clipboard me-1"></i> Copy Logs
                    </button>
                </div>
                <div class="sys-log" id="sysLog">System Initialized.</div>
            </div>
        </div>

    </div>
</div>

<!-- TOAST CONTAINER -->
<div class="toast-container" id="toastContainer"></div>

<!-- MODALS -->
<div class="modal fade" id="settingsModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Settings</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" onclick="GUI.toggleSettings()"></button>
      </div>
      <div class="modal-body">
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="showEvalToggle" checked onchange="GUI.toggleEvalBar(this.checked)">
            <label class="form-check-label" for="showEvalToggle">Show Eval Bar (Computer Play)</label>
        </div>
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="showLogsSwitch" onchange="GUI.toggleLogs(this.checked)">
            <label class="form-check-label" for="showLogsSwitch">Show System Logs</label>
        </div>
        <hr>
        <div class="mb-3">
            <label class="form-label small fw-bold">Data Profile ID (UID Override)</label>
            <input type="text" id="dataProfileIdInput" class="form-control form-control-sm" placeholder="Paste UID Here...">
            <button class="btn btn-sm btn-success mt-2 w-100" onclick="GUI.updateDataProfile()">Save Profile ID & Reload Data</button>
            <div class="small text-muted mt-2">Current Active ID: <span id="currentActiveDataId">...</span></div>
        </div>
        <div class="mb-3">
            <label class="form-label small fw-bold">Gemini API Key</label>
            <input type="password" id="apiKeyInput" class="form-control form-control-sm" placeholder="Paste Key Here...">
            <button class="btn btn-sm btn-outline-primary mt-2" onclick="localStorage.setItem('gemini_api_key', document.getElementById('apiKeyInput').value); GUI.showToast('API Key Saved!', 'success')">Save Key</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="pgnModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Paste PGN</h5>
        <button type="button" class="btn-close" onclick="document.getElementById('pgnModal').style.display='none'; document.getElementById('pgnModal').classList.remove('show')"></button>
      </div>
      <div class="modal-body">
        <textarea id="pgnText" class="form-control" rows="8" placeholder="[Event ...] 1. e4 e5 ..."></textarea>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" onclick="importManualPGN()">Import Game</button>
      </div>
    </div>
  </div>
</div>

<!-- SCRIPTS -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script type="module">
// --- FIREBASE IMPORTS ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, collection, query, onSnapshot, doc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// --- CONFIG ---
const STOCKFISH_URL = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
const MODEL_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent';
const apiKey = ""; 

// --- FIREBASE GLOBALS ---
let app, db, auth;
let authUserId = null; // The secure Firebase authenticated UID
let activeDataUserId = null; // The ID currently used for Firestore paths (can be overridden)
let gamesUnsubscribe = null;
let puzzlesUnsubscribe = null;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

/**
 * UTILITIES
 */
window.sys_logs = []; 
function log(msg, type = 'INFO') {
    const box = document.getElementById('sysLog');
    const now = new Date();
    const time = now.toLocaleTimeString().split(' ')[0];
    
    window.sys_logs.push({ timestamp: now.toISOString(), type: type, message: msg });
    
    const div = document.createElement('div');
    
    let color = '#4ade80'; // INFO (green)
    if (type === 'ERROR') color = '#f87171'; // Red
    else if (type === 'WARN') color = '#facc15'; // Yellow
    
    div.innerHTML = `<span style="color: ${color};">[${type}]</span> [${time}] ${msg}`;
    div.className = 'log-line'; 
    if (box) {
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }
}

function getEffectiveKey() {
    if(apiKey && apiKey.length > 0) return apiKey;
    return localStorage.getItem('gemini_api_key') || "";
}

/**
 * ENGINE (Stockfish)
 */
const Engine = {
    worker: null,
    isReady: false,
    
    init: function() {
        log("Loading Stockfish 10.0.2...");
        try {
            const blob = new Blob([`importScripts('${STOCKFISH_URL}');`], {type: 'application/javascript'});
            this.worker = new Worker(URL.createObjectURL(blob));
            this.worker.postMessage('uci');
            this.worker.postMessage('setoption name UCI_ShowWDL value true'); 
            this.worker.onmessage = (e) => this.handleMessage(e.data);
            this.worker.onerror = (e) => {
                log("Engine Worker Error: " + e.message, 'ERROR');
                document.getElementById('engineStatus').className = "badge bg-danger";
                document.getElementById('engineStatus').innerText = "Failed";
            };
        } catch(e) { 
            log("Engine Init Error: " + e, 'ERROR'); 
            document.getElementById('engineStatus').className = "badge bg-danger";
            document.getElementById('engineStatus').innerText = "Failed";
        }
    },

    handleMessage: function(line) {
        if(line === 'uciok') {
            this.isReady = true;
            document.getElementById('engineStatus').className = "badge bg-success";
            document.getElementById('engineStatus').innerText = "Ready";
            log("Stockfish Ready.");
        }
    },

    setSkill: function(val) {
        if(!this.isReady) return;
        this.worker.postMessage(`setoption name Skill Level value ${val}`);
        const err = Math.max(0, 20 - val) * 20;
        this.worker.postMessage(`setoption name Skill Level Probability value ${err}`);
    },

    stop: function() {
        if(this.isReady) this.worker.postMessage('stop');
    },

    runScan: function(fen) {
        return new Promise(resolve => {
            if(!this.isReady) {
                resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null });
                return;
            }
            
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;

            const tId = setTimeout(() => {
                this.worker.onmessage = oldHandler; 
                resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null });
            }, 6000); 

            let best="-", ev="0.00", pv="", wdl=null;

            const list = (e) => {
                const l = e.data;
                if (l.includes(' pv ')) pv = l.split(' pv ')[1];
                if (l.includes(' wdl ')) { const m=l.match(/wdl (\d+) (\d+) (\d+)/); if(m) wdl=[parseInt(m[1]), parseInt(m[2]), parseInt(m[3])]; }
                if (l.includes('cp ')) { const m=l.match(/cp (-?\d+)/); if(m) ev=(parseInt(m[1])/100 * (fen.includes(' b ')?-1:1)).toFixed(2); }
                if (l.includes('mate ')) { const m=l.match(/mate (-?\d+)/); if(m) ev="M"+(parseInt(m[1])); }
                
                if (l.startsWith('bestmove')) {
                    clearTimeout(tId);
                    best = l.split(' ')[1];
                    this.worker.onmessage = oldHandler; 
                    if(!wdl && !ev.toString().startsWith('M')) wdl = this.estimateWDL(parseFloat(ev));
                    resolve({ eval: ev, bestMove: best, pv: pv, wdl: wdl });
                }
            };
            this.worker.onmessage = (e) => list(e);
            
            this.worker.postMessage('stop');
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 12'); 
        });
    },

    estimateWDL: function(ev) {
        const w = 1000 / (1 + Math.exp(-ev));
        const l = 1000 - w;
        return [Math.round(w), 0, Math.round(l)];
    },

    getBestMove: function(fen) {
        return new Promise(resolve => {
            if(!this.isReady) resolve(null);
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;
            const listener = (e) => {
                if(e.data.startsWith('bestmove')) {
                    const move = e.data.split(' ')[1];
                    this.worker.onmessage = oldHandler;
                    resolve(move);
                }
            };
            this.worker.onmessage = (e) => listener(e);
            this.worker.postMessage('stop');
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 12');
        });
    },
    
    analyze: function(fen) {
        if(!this.isReady) return;
        this.worker.postMessage('stop');
        this.worker.postMessage(`position fen ${fen}`);
        this.worker.postMessage('go depth 14');
        
        const listener = (e) => {
            const line = e.data;
            let cp = 0, mate = null;
            
            if(line.includes('score mate')) {
                const m = line.match(/score mate (-?\d+)/);
                if(m) mate = parseInt(m[1]);
            } else if(line.includes('score cp')) {
                const m = line.match(/score cp (-?\d+)/);
                if(m) cp = parseInt(m[1]);
            }

            if (line.includes(' pv ')) {
                let activeColor = fen.split(' ')[1];
                let evalVal = cp;
                if(activeColor === 'b') {
                    evalVal = -cp;
                    if(mate !== null) mate = -mate;
                }
                // STRICT CHECK: Only update eval if the analyzed fen matches current board
                if (Game.getActiveChess().fen().split(' ')[0] === fen.split(' ')[0]) {
                    GUI.updateEval(evalVal, mate);
                }
            }
            if(line.startsWith('bestmove')) this.worker.removeEventListener('message', listener);
        };
        this.worker.addEventListener('message', listener);
    },
    
    playResponse: function(fen) {
          if(!this.isReady) return;
          
          // FIX: Increased watchdog time from 3s to 8s
          const watchdog = setTimeout(() => {
              log("WARN: Engine timed out (8s). Forcing stop and reset.", 'WARN');
              this.worker.removeEventListener('message', listener);
              this.worker.postMessage('stop');
              this.worker.postMessage('ucinewgame'); 
              document.getElementById('boardCard').classList.remove('opacity-50');
          }, 8000); 

          this.worker.postMessage('stop');
          this.worker.postMessage(`position fen ${fen}`);
          this.worker.postMessage('go movetime 1000'); 
          
          const listener = (e) => {
              if(e.data.startsWith('bestmove')) {
                  clearTimeout(watchdog); 
                  const best = e.data.split(' ')[1];
                  this.worker.removeEventListener('message', listener);
                  Game.engineMove(best);
              }
          };
          this.worker.addEventListener('message', listener);
    },

    getTopMoves: function(fen, count) {
        return new Promise(resolve => {
            if(!this.isReady) resolve([]);
            let moves = [];
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;
            const listener = (e) => {
                const line = e.data;
                if(line.startsWith('info') && line.includes('multipv') && line.includes('pv')) {
                    const parts = line.split(' pv ');
                    if(parts[1]) {
                        const m = parts[1].split(' ')[0];
                        if (!moves.includes(m)) moves.push(m);
                    }
                }
                if(line.startsWith('bestmove')) {
                    this.worker.onmessage = oldHandler;
                    resolve(moves);
                }
            };
            this.worker.onmessage = (e) => listener(e);
            this.worker.postMessage('stop');
            this.worker.postMessage(`setoption name MultiPV value ${count}`);
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 10'); 
            setTimeout(() => this.worker.postMessage('setoption name MultiPV value 1'), 500); 
        });
    }
};

/**
 * TACTICAL HEAT MAP ENGINE - V2 (Defenders/Attackers)
 */
const HeatMap = {
    val: { p: 1, n: 3, b: 3, r: 5, q: 9, k: 100 },
    
    analyze: function(chess) {
        const fen = chess.fen();
        const turn = chess.turn();
        const opp = turn === 'w' ? 'b' : 'w';
        
        const myDefenses = this.getDetailedAttacks(chess, turn); 
        const oppAttacks = this.getDetailedAttacks(chess, opp); 

        let hanging = [];
        let pressure = [];
        let radar = []; // For Gemini

        const board = chess.board(); 
        const files = ['a','b','c','d','e','f','g','h'];

        for(let r=0; r<8; r++){
            for(let c=0; c<8; c++){
                const piece = board[r][c];
                if(piece && piece.color === turn) {
                    const sq = files[c] + (8-r);
                    const attackers = oppAttacks[sq] || [];
                    const defenders = myDefenses[sq] || [];
                    
                    const atkCount = attackers.length;
                    const defCount = defenders.length;

                    if (atkCount > 0) {
                        const atkStr = attackers.map(p => p.toUpperCase()).join(', '); 
                        const defStr = defenders.map(p => p.toUpperCase()).join(', '); 
                        
                        let status = "Safe";
                        if (defCount === 0) {
                            status = "HANGING";
                            hanging.push(sq);
                        } else if (atkCount > defCount) {
                            status = "OVERWHELMED";
                            pressure.push(sq);
                        } else {
                            status = "Contested";
                        }

                        // Detailed string for Gemini
                        radar.push(`${piece.type.toUpperCase()} at ${sq}: Attacked by ${atkCount} (${atkStr}), Defended by ${defCount} (${defStr}). Status: ${status}`);
                    }
                }
            }
        }
        
        return { 
            hanging: hanging, 
            pressure: pressure, 
            radar: radar 
        };
    },

    // Returns Map: Square -> ['p', 'n', 'q'...] (Types of attackers)
    getDetailedAttacks: function(chessInstance, color) {
        const temp = new Chess(chessInstance.fen());
        // Force turn to generate moves
        if (temp.turn() !== color) {
            const tokens = temp.fen().split(' ');
            tokens[1] = color;
            tokens[3] = '-'; 
            temp.load(tokens.join(' '));
        }
        
        const moves = temp.moves({ verbose: true });
        const attackMap = {};
        
        moves.forEach(m => {
            if (!attackMap[m.to]) attackMap[m.to] = [];
            // Push the piece type that is attacking
            attackMap[m.to].push(m.piece);
        });
        return attackMap;
    }
};

/**
 * GEMINI AI
 */
const Gemini = {
    comments: {}, 
    getCommentary: async function(analysisData, openingName, focus) {
        const k = getEffectiveKey();
        if (!k) { GUI.showToast("Please set API Key in Settings!", "error"); return false; }

        let logStr = `Game Context:\nOpening: ${openingName}\n\n`;
        
        analysisData.forEach((d, i) => {
            const isUserTurn = (focus === 'both' || focus === d.color);
            if (!isUserTurn) return;

            let evalText = d.eval;
            if(d.eval.toString().startsWith('M')) evalText = `Mate in ${d.eval.replace('M','')}`;

            const moveInfo = `[PLY ${i+1}] ${d.color==='w'?'White':'Black'} played ${d.san}`;
            const engineInfo = `\n    - Best Move: ${d.bestMoveSan || '?'}`;
            const engineLine = `\n    - PV (Engine Plan): ${d.pvSan || 'None'}`;
            
            const heat = d.tactics || { hanging: [], pressure: [], radar: [] };
            let tacticalText = "\n    - Tactical Status (Before Move):\n";
            if (heat.radar.length === 0) tacticalText += "      No immediate threats detected.";
            else heat.radar.forEach(line => tacticalText += `      * ${line}\n`);

            const outcome = `\n    - Result: Eval ${evalText}, Class ${d.classification}`;
            
            logStr += `${moveInfo} ${tacticalText} ${engineInfo} ${engineLine} ${outcome}\n\n`;
        });

        if (logStr.length < 50) logStr = "Game was short.";

        const prompt = `
You are a Grandmaster Chess Coach.

**YOUR DATA SOURCE:**
For every move, I have provided:
1. The Move & Engine Best Move.
2. **Tactical Radar:** This gives you a heatmap of EXACTLY who is attacking and defending each piece.
   - Example: "N at f3: Attacked by 2 (Q, R), Defended by 1 (P). Status: OVERWHELMED".
3. **Principal Variation (PV):** The future moves the engine predicts.

**CRITICAL INSTRUCTIONS:**
1. **No Meta-Talk:** Do NOT mention phrases like "The Tactical Radar shows", "The data indicates", or "My sensors detect". Speak naturally, like a human coach looking at the board.
2. **Book Moves:** If a move is classified as 'Book', explain the strategic opening principle (e.g., controlling center, developing pieces). DO NOT CRITICIZE IT.
3. **Defensive Logic:** If a move defends a piece that was listed as 'HANGING' or 'OVERWHELMED', acknowledge the defense. Do NOT say the piece is ignored if the move successfully defends it.
4. **JSON ONLY:** Return *only* the JSON object.

**TASK:**
Explain the moves in the provided game log.

**JSON Format:**
{
    "12": {
        "analysis": "This pawn push is a mistake. Your Knight on f3 was overwhelmed (2 attackers vs 1 defender), and this move unpins it but loses material.",
        "pv_explanation": ["Nf3 prevents the fork", "Be2 prepares castling"] 
    }
}

**Game Log:**
${logStr}
        `;

        try {
            log("Sending rich context request to Gemini...");
            
            const res = await fetch(MODEL_ENDPOINT+`?key=${k}`, {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });

            const d = await res.json();
            if(!d.candidates || !d.candidates[0]) {
                log("Gemini API returned no content.", 'ERROR');
                return false;
            }
            const text = d.candidates[0].content.parts[0].text;
            let cleanText = text.replace(/```json/g, '').replace(/```/g, '');
            const start = cleanText.indexOf('{');
            const end = cleanText.lastIndexOf('}');
            if (start !== -1 && end !== -1) {
                cleanText = cleanText.substring(start, end + 1);
                this.comments = JSON.parse(cleanText);
                log("Gemini Analysis Complete.");
                return true;
            }
            log("Gemini response was not valid JSON.", 'ERROR');
            return false;
        } catch (e) { 
            console.error("Gemini Error", e);
            if (e.name === 'AbortError') {
                log("Coach Analysis Failed (Request Aborted). Retrying or check network.", 'ERROR');
            } else {
                GUI.showToast("Coach Analysis Failed (Network/API). Check System Log.", 'ERROR');
            }
            return false; 
        }
    }
};

/**
 * FIREBASE / PUZZLE ARCHIVE MANAGEMENT
 */
const PuzzleArchive = {
    data: [], // Stores all archived puzzles
    currentPuzzle: null,

    // Firestore Integration for Puzzles
    loadFromStorage: function() {
        if (!activeDataUserId || !db) return;
        if (puzzlesUnsubscribe) puzzlesUnsubscribe(); 

        const userPuzzlesRef = collection(db, `artifacts/${appId}/users/${activeDataUserId}/puzzles`);
        const q = query(userPuzzlesRef);

        puzzlesUnsubscribe = onSnapshot(q, (snapshot) => {
            this.data = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            document.getElementById('archiveBadge').innerText = this.data.length;
            document.getElementById('archiveBadge').classList.toggle('d-none', this.data.length === 0);
            this.renderList();
            log(`Loaded ${this.data.length} archived puzzles for profile: ${activeDataUserId.substring(0, 8)}...`);
        }, (error) => {
            log("Firestore Puzzle Snapshot Error: " + error.message, 'ERROR');
        });
    },
    
    savePuzzle: async function(puzzle) {
        if (!activeDataUserId || !db) { log("Cannot save puzzle: Firebase not initialized.", 'ERROR'); return; }
        const puzzleId = puzzle.id.toString();
        const puzzleRef = doc(db, `artifacts/${appId}/users/${activeDataUserId}/puzzles`, puzzleId);
        await setDoc(puzzleRef, puzzle);
    },

    deletePuzzle: async function(id) {
        if (!activeDataUserId || !db) { log("Cannot delete puzzle: Firebase not initialized.", 'ERROR'); return; }
        const puzzleRef = doc(db, `artifacts/${appId}/users/${activeDataUserId}/puzzles`, id.toString());
        await deleteDoc(puzzleRef);
        GUI.showToast("Puzzle deleted.", "success");
    },
    
    // UI Rendering and Logic
    renderList: function() {
        const list = document.getElementById('puzzleArchiveList');
        list.innerHTML = "";
        if (this.data.length === 0) {
            list.innerHTML = '<div class="p-3 text-center text-muted small">No puzzles saved yet. Analyze a game to generate some!</div>';
            return;
        }

        this.data.forEach(p => {
            const div = document.createElement('div');
            div.className = "puzzle-item rounded d-flex justify-content-between align-items-center";
            div.innerHTML = `
                <div onclick="PuzzleArchive.loadPuzzle('${p.id}')">
                    <div class="fw-bold">FEN: ${p.fen.split(' ')[0]}</div>
                    <div class="small text-muted">Solution: ${p.solution.substring(0, 4)}...  Turn: ${p.color.toUpperCase()}  Difficulty: ${p.difficulty}</div>
                </div>
                <button class="btn btn-sm btn-outline-danger ms-2" onclick="event.stopPropagation(); PuzzleArchive.deletePuzzle('${p.id}')" title="Delete Puzzle">
                    <i class="fa-solid fa-trash-can fa-xs"></i>
                </button>
            `;
            list.appendChild(div);
        });
    },

    loadPuzzle: function(id) {
        const puzzle = this.data.find(p => p.id.toString() === id.toString());
        if (puzzle) {
            // Load this puzzle into the PuzzleManager's state
            Game.puzzles = [puzzle];
            PuzzleManager.currentIdx = 0;
            
            // Switch tab and load the puzzle board
            GUI.switchTab('puzzles');
            GUI.showToast("Puzzle loaded from Archive.", "success");
        }
    },
    
    randomize: function() {
        if (this.data.length === 0) {
            GUI.showToast("No puzzles in archive to randomize.", "error");
            return;
        }
        const randomIdx = Math.floor(Math.random() * this.data.length);
        const randomPuzzle = this.data[randomIdx];
        this.loadPuzzle(randomPuzzle.id);
    }
}


/**
 * GAME LOGIC
 */
const Game = {
    data: [], // Array of game objects (synced with Firestore)
    
    // TWO Separate Board States
    analysisChess: new Chess(),
    playChess: new Chess(),
    
    history: [],
    index: -1,
    userColor: 'w',
    playUserColor: 'w', 
    playViewIndex: -1, 
    analysisData: [], 
    puzzles: [], // Puzzles generated from the currently loaded game
    mode: 'analysis',
    selectedSquare: null, 
    
    // FIREBASE PERSISTENCE FUNCTIONS
    saveGame: async function(game) {
        if (!activeDataUserId || !db) { log("Cannot save: Firebase not initialized or user not logged in.", 'ERROR'); return; }
        const gameId = game.id.toString(); 
        const gameRef = doc(db, `artifacts/${appId}/users/${activeDataUserId}/chess_games`, gameId);
        await setDoc(gameRef, { ...game, id: gameId }); 
        log(`Game saved to Firestore: ${game.opening} (${gameId})`);
    },

    deleteGame: async function(id) {
        if (!activeDataUserId || !db) { log("Cannot delete: Firebase not initialized or user not logged in.", 'ERROR'); return; }
        const gameRef = doc(db, `artifacts/${appId}/users/${activeDataUserId}/chess_games`, id.toString());
        await deleteDoc(gameRef);
        GUI.showToast("Game deleted.", "success");
    },

    loadFromStorage: function() {
        if (!activeDataUserId || !db) return;
        if (gamesUnsubscribe) gamesUnsubscribe(); 

        const userGamesRef = collection(db, `artifacts/${appId}/users/${activeDataUserId}/chess_games`);
        const q = query(userGamesRef);

        gamesUnsubscribe = onSnapshot(q, (snapshot) => {
            Game.data = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            
            Game.data.sort((a,b) => b.id.localeCompare(a.id)); 
            renderList();
            log(`Loaded ${Game.data.length} games for profile: ${activeDataUserId.substring(0, 8)}...`);

            if (Game.data.length > 0 && Game.index === -1) {
                Game.load(Game.data[0].id);
            } else if (Game.data.length === 0) {
                document.getElementById('gameList').innerHTML = '<div class="p-3 text-center text-muted small">Upload CSV or PGN to load games</div>';
            }
        }, (error) => {
            log("Firestore Snapshot Error: " + error.message, 'ERROR');
        });
        
        // Load puzzle archive data
        PuzzleArchive.loadFromStorage();
    },

    // GAME LOGIC CONTINUES
    getActiveChess: function() {
        if (this.mode === 'play') {
             if (this.playViewIndex !== -1) {
                 const temp = new Chess();
                 const history = this.playChess.history({ verbose: true });
                 for (let i = 0; i <= this.playViewIndex; i++) {
                     temp.move(history[i].san);
                 }
                 return temp;
             }
             return this.playChess;
        }
        return this.analysisChess;
    },

    cleanPGN: function(pgn) {
        if (!pgn) return "";
        let body = pgn.replace(/\[.*?\]/g, ' ').replace(/\{.*?\}/g, ' ').replace(/\(.*?\)/g, ' ').replace(/\$\d+/g, ' ');
        return body.replace(/\s+/g, ' ').trim();
    },

    load: function(id) {
        const g = this.data.find(x => x.id.toString() === id.toString());
        if(!g) return;
        
        log(`Loading Game ID ${id}...`);
        this.analysisChess.reset();
        
        const movesOnly = this.cleanPGN(g.pgn);
        let success = this.analysisChess.load_pgn(movesOnly);
        if(!success) success = this.analysisChess.load_pgn(g.pgn);
        
        if(!success) {
            log("ERROR: PGN Parse Failed. Make sure PGN is valid.", 'ERROR');
            return;
        }
        
        this.history = this.analysisChess.history({ verbose: true });
        this.resetToStart();
        
        document.getElementById('gameTitle').innerText = g.opening;
        document.getElementById('scanBtn').disabled = false;
        
        this.analysisData = [];
        this.puzzles = [];
        Gemini.comments = {};
        
        document.getElementById('puzzleBadge').innerText = "0";
        document.getElementById('puzzleBadge').classList.add('d-none');
        document.getElementById('board').classList.remove('opacity-50');

        let rawColor = (g.userColor || 'white').toLowerCase();
        this.userColor = rawColor.startsWith('b') ? 'b' : 'w';
        
        GUI.board.orientation(this.userColor === 'b' ? 'black' : 'white');
        GUI.switchTab('analysis');
        setTimeout(() => GUI.board.resize(), 100);
    },
    
    resetToStart: function() {
        this.analysisChess.reset();
        this.index = -1;
        GUI.update();
        Engine.analyze(this.analysisChess.fen());
    },
    
    move: function(from, to, prom) {
        const chess = this.getActiveChess();
        
        if (this.mode === 'play' && this.playViewIndex !== -1) return false;
        
        const move = chess.move({ from: from, to: to, promotion: prom || 'q' });
        
        if(move) {
            if (this.mode === 'analysis') {
                this.index++; 
                GUI.update();
                Engine.analyze(chess.fen());
            } 
            else if (this.mode === 'play') {
                this.playViewIndex = -1; 
                GUI.board.position(this.playChess.fen()); 
                GUI.update();
                if (this.playChess.in_checkmate()) document.getElementById('checkmateOverlay').classList.remove('d-none');
                
                if (!this.playChess.game_over()) {
                    Engine.playResponse(this.playChess.fen());
                }
                Engine.analyze(this.playChess.fen());
            }
            GUI.clearArrows();
            return true;
        }
        return false;
    },

    engineMove: function(bestMoveUci) {
        if (this.mode !== 'play') return;
        
        const from = bestMoveUci.substring(0,2);
        const to = bestMoveUci.substring(2,4);
        const prom = bestMoveUci.length > 4 ? bestMoveUci.substring(4,5) : 'q';
        
        this.playChess.move({ from: from, to: to, promotion: prom });
        GUI.board.position(this.playChess.fen()); 
        GUI.update();
        document.getElementById('boardCard').classList.remove('opacity-50'); 
        if (this.playChess.in_checkmate()) document.getElementById('checkmateOverlay').classList.remove('d-none');
        Engine.analyze(this.playChess.fen());
    },
    
    navPlay: function(dir) {
        const history = this.playChess.history({ verbose: true });
        const len = history.length;
        
        const lastMoveIndex = len - 1;

        if (dir === 'next') {
            this.playViewIndex = Math.min(lastMoveIndex, this.playViewIndex + 1);
        } else if (dir === 'prev') {
            this.playViewIndex = Math.max(-1, this.playViewIndex - 1);
        } else if (dir === 'first') {
            this.playViewIndex = -1; 
        } else if (dir === 'last') {
            this.playViewIndex = lastMoveIndex;
        }

        const tempChess = new Chess();
        if (this.playViewIndex >= 0) {
            for (let i = 0; i <= this.playViewIndex; i++) {
                tempChess.move(history[i].san);
            }
            GUI.board.position(tempChess.fen());
            document.getElementById('boardCard').classList.add('opacity-50');
            Engine.stop();
            GUI.updateEval(0, null);
        } else {
            GUI.board.position(this.playChess.fen());
            document.getElementById('boardCard').classList.remove('opacity-50');
            Engine.analyze(this.playChess.fen());
        }
        GUI.clearArrows();
    },

    nav: function(dir) {
        if (this.mode === 'play') {
            this.navPlay(dir);
            return;
        }

        if (this.mode !== 'analysis') return;

        document.getElementById('checkmateOverlay').classList.add('d-none');
        GUI.clearArrows();
        
        if(dir === 'next' && this.index < this.history.length - 1) {
            this.index++;
            this.analysisChess.move(this.history[this.index].san);
        } else if (dir === 'prev' && this.index >= 0) {
            this.analysisChess.undo();
            this.index--;
        } else if (dir === 'first') {
            this.analysisChess.reset();
            this.index = -1;
        } else if (dir === 'last') {
            while(this.index < this.history.length - 1) {
                this.index++;
                this.analysisChess.move(this.history[this.index].san);
            }
        }
        GUI.update();
        Engine.analyze(this.analysisChess.fen());
    }
};

/**
 * SCANNER - The Truth Pipeline
 */
const Scanner = {
    start: async function() {
        const btn = document.getElementById('scanBtn');
        const bar = document.getElementById('scanBar');
        const text = document.getElementById('scanText');
        const progressBox = document.getElementById('scanProgress');
        const focus = document.getElementById('analysisFocus').value;
        const navBtns = document.querySelectorAll('#verticalAnalysisControls button');

        if (!Game.history || Game.history.length === 0) {
            GUI.showToast("No moves to analyze! Load a game first.", "error");
            return;
        }

        // Reset and show UI
        btn.disabled = true;
        navBtns.forEach(b => b.disabled = true);
        
        progressBox.classList.remove('d-none');
        bar.style.width = '0%';
        bar.className = "progress-bar progress-bar-striped progress-bar-animated"; 
        
        try {
            Game.analysisData = []; 
            Game.puzzles = []; 
            
            const moves = Game.history;
            const tempChess = new Chess();
            
            for(let i=0; i<moves.length; i++) {
                await new Promise(r => setTimeout(r, 20));

                const fenBefore = tempChess.fen();
                
                let isBook = false;
                if (i < 15) {
                    const bookResult = await this.fetchBookData(fenBefore);
                    if (bookResult) {
                        const bookMoves = bookResult.moves.map(m => m.uci);
                        const moveObj = moves[i];
                        const userUci = moveObj.from + moveObj.to + (moveObj.promotion || '');
                        if (bookMoves.includes(userUci)) isBook = true;
                    }
                }

                const tacticalSnapshot = HeatMap.analyze(tempChess);

                const preMoveResult = await Engine.runScan(fenBefore);
                let scoreBefore = this.parseEval(preMoveResult.eval);
                
                let bestMoveSan = preMoveResult.bestMove;
                let bestLineSan = "";

                if(preMoveResult.bestMove && preMoveResult.bestMove !== '-') {
                    const simGame = new Chess(fenBefore);
                    const bm = simGame.move({ from: preMoveResult.bestMove.substring(0,2), to: preMoveResult.bestMove.substring(2,4), promotion: 'q' });
                    if(bm) bestMoveSan = bm.san;
                    if(preMoveResult.pv) bestLineSan = this.uciToSan(fenBefore, preMoveResult.pv);
                }

                const moveObj = moves[i];
                const userUci = moveObj.from + moveObj.to + (moveObj.promotion || '');
                
                tempChess.move(moveObj.san);
                const fenAfter = tempChess.fen();
                
                const isMate = tempChess.in_checkmate();
                let scoreAfter = 0;
                let evAfterStr = "";

                if (isMate) {
                    scoreAfter = (moveObj.color === 'w') ? 100 : -100;
                    evAfterStr = "M0"; 
                } else {
                    const postMoveResult = await Engine.runScan(fenAfter);
                    evAfterStr = postMoveResult.eval;
                    scoreAfter = this.parseEval(postMoveResult.eval);
                }

                let loss = 0;
                if (moveObj.color === 'w') loss = scoreBefore - scoreAfter;
                else loss = scoreAfter - scoreBefore;
                
                let cls = "Neutral";
                
                if (isBook) cls = "Book";
                else if (isMate) cls = "Best";
                else if (userUci === preMoveResult.bestMove) cls = "Best";
                else {
                    const wasWinning = (moveObj.color === 'w' ? scoreBefore > 2 : scoreBefore < -2);
                    const isWinning = (moveObj.color === 'w' ? scoreAfter > 1 : scoreAfter < -1);
                    
                    if (wasWinning && !isWinning) cls = "Missed"; 
                    else if (loss >= 2.0) cls = "Blunder";
                    else if (loss >= 1.0) cls = "Mistake";
                    else if (loss >= 0.5) cls = "Inaccuracy";
                    else if (loss >= 0.2) cls = "Good";
                    else if (loss >= 0.05) cls = "Excellent";
                    else cls = "Best"; 
                }
                
                const analysisItem = {
                    san: moveObj.san, color: moveObj.color,
                    eval: evAfterStr, 
                    evalDiff: loss.toFixed(2),
                    wdl: preMoveResult.wdl,
                    bestMoveSan: bestMoveSan,
                    pvSan: bestLineSan,
                    classification: cls,
                    fenBefore: fenBefore,
                    isMate: isMate,
                    tactics: tacticalSnapshot
                };

                Game.analysisData.push(analysisItem);
                
                if ((cls === 'Blunder' || cls === 'Mistake' || cls === 'Missed') && moveObj.color === Game.userColor) {
                    const newPuzzle = { 
                        id: Date.now().toString() + i, 
                        fen: fenBefore, 
                        color: moveObj.color, 
                        solution: preMoveResult.bestMove,
                        difficulty: cls 
                    };
                    Game.puzzles.push(newPuzzle);
                    PuzzleArchive.savePuzzle(newPuzzle); 
                }

                bar.style.width = Math.round(((i+1)/moves.length)*50) + "%"; 
                text.innerText = `Analyzing: ${i+1}/${moves.length}`;
            }

            if (Game.puzzles.length > 0) {
                document.getElementById('puzzleBadge').innerText = Game.puzzles.length;
                document.getElementById('puzzleBadge').classList.remove('d-none');
            }

            text.innerText = "Consulting Grandmaster Coach...";
            document.getElementById('coachDisplay').innerHTML = '<div class="text-center p-3 text-muted"><i class="fa-solid fa-brain fa-spin me-2"></i> Analyzing threats & variations...</div>';
            bar.className = "progress-bar bg-success progress-bar-striped progress-bar-animated";
            
            await Gemini.getCommentary(Game.analysisData, "Custom Game", focus);
            
            bar.style.width = "100%";

            Game.nav('first'); 
            setTimeout(() => { Game.nav('next'); }, 600);

            GUI.showToast("Analysis Complete. Puzzles saved to Archive.", "success");

        } catch(err) {
            console.error(err);
            GUI.showToast("Analysis Failed. Check logs.", "error");
        } finally {
            setTimeout(() => { 
                progressBox.classList.add('d-none'); 
                btn.disabled = false;
                navBtns.forEach(b => b.disabled = false); 
            }, 1000);
        }
    },

    fetchBookData: async function(fen) {
        try { 
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000);
            
            const res = await fetch(`https://explorer.lichess.ovh/masters?fen=${fen}`, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if(res.ok) return await res.json();
        } catch(e){ return null; }
        return null;
    },
    parseEval: function(str) {
        if (typeof str === 'string' && str.startsWith('M')) {
             const moves = parseInt(str.replace('M', ''));
             if (moves === 0) return 100; 
             return moves > 0 ? 10 : -10; 
        }
        return parseFloat(str);
    },
    uciToSan: function(fen, pv) {
        if(!pv) return "";
        const t = new Chess(fen);
        let s = "";
        const mvs = pv.split(' ');
        for(let m of mvs) {
            if(!m) continue;
            const mo = t.move({from:m.substring(0,2), to:m.substring(2,4), promotion: m.length>4?m.substring(4,5):undefined});
            if(mo) s += mo.san + " "; else break;
        }
        return s.trim();
    }
};

/**
 * PUZZLE MANAGER
 */
const PuzzleManager = {
    currentIdx: 0,
    activePuzzle: null,
    vsEngine: false,

    init: function() { this.vsEngine = false; },

    toggleEngineMode: function() {
        this.vsEngine = document.getElementById('puzzleVsEngine').checked;
        const feedback = document.getElementById('puzzleFeedback');
        if (this.vsEngine) {
            feedback.innerHTML = '<span class="text-primary"><i class="fa-solid fa-robot"></i> Engine Mode: Play any move.</span>';
        } else {
            feedback.innerHTML = '';
            if(this.activePuzzle) {
                Game.analysisChess.load(this.activePuzzle.fen); 
                GUI.board.position(this.activePuzzle.fen);
            }
        }
    },

    loadPuzzles: function() {
        if (Game.puzzles.length === 0) {
            document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted">No puzzles loaded. Analyze a game or check the Archive.</span>`;
            document.getElementById('board').classList.add('opacity-50');
            return;
        }
        document.getElementById('board').classList.remove('opacity-50');
        document.getElementById('puzzleEngineContainer').classList.remove('d-none');
        this.currentIdx = 0;
        this.showPuzzle(0);
    },

    showPuzzle: function(idx) {
        if (Game.puzzles.length === 0) return;
        if (idx >= Game.puzzles.length) {
            document.getElementById('puzzleFeedback').innerHTML = `<span class="text-primary fw-bold">Training Complete!</span>`;
            return;
        }
        
        this.currentIdx = idx;
        this.activePuzzle = Game.puzzles[idx];
        
        Game.analysisChess.load(this.activePuzzle.fen);
        GUI.board.position(this.activePuzzle.fen);
        GUI.board.orientation(this.activePuzzle.color === 'w' ? 'white' : 'black');
        GUI.clearArrows();
        GUI.updateMaterial(); 
        
        document.getElementById('puzzleCountBadge').innerText = `Puzzle ${idx + 1}/${Game.puzzles.length}`;
        document.getElementById('puzzleFeedback').innerHTML = "";
    },

    handleDrop: async function(source, target) {
        if (this.vsEngine) {
            const move = Game.analysisChess.move({ from: source, to: target, promotion: 'q' });
            if (move) {
                GUI.update();
                Engine.analyze(Game.analysisChess.fen());
                if (!Game.analysisChess.game_over()) {
                     setTimeout(async () => {
                        const best = await Engine.getBestMove(Game.analysisChess.fen());
                        if (best) {
                            Game.analysisChess.move({ from: best.substring(0,2), to: best.substring(2,4), promotion: 'q' });
                            GUI.update();
                            Engine.analyze(Game.analysisChess.fen());
                        }
                    }, 500);
                }
                return undefined;
            }
            return 'snapback';
        }

        const valid = await this.validateMove(source, target);
        if (valid) {
            Game.analysisChess.move({ from: source, to: target, promotion: 'q' });
            GUI.updateMaterial();
            return undefined;
        } else {
            return 'snapback';
        }
    },

    validateMove: async function(source, target) {
        if (!this.activePuzzle) return false;
        
        const userUci = source + target; 
        const primarySol = this.activePuzzle.solution;
        
        if (primarySol.indexOf(userUci) === 0) {
            this.onSuccess();
            return true;
        }
        
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted"><i class="fa-solid fa-spinner fa-spin"></i> Checking alternative...</span>`;
        const topMoves = await Engine.getTopMoves(this.activePuzzle.fen, 3);
        const isGood = topMoves.some(m => m.indexOf(userUci) === 0);
        
        if (isGood) {
            this.onSuccess();
            return true;
        } else {
            this.onFail();
            return false;
        }
    },

    onSuccess: function() {
        document.getElementById('board').classList.add('puzzle-success');
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-correct"><i class="fa-solid fa-check"></i> Correct!</span>`;
        setTimeout(() => {
            document.getElementById('board').classList.remove('puzzle-success');
            if (!this.vsEngine) this.next(); 
        }, 500);
    },

    onFail: function() {
        document.getElementById('board').classList.add('puzzle-fail');
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-incorrect"><i class="fa-solid fa-xmark"></i> Incorrect. Try again.</span>`;
        setTimeout(() => {
            document.getElementById('board').classList.remove('puzzle-fail');
            document.getElementById('puzzleFeedback').innerHTML = "";
            if(this.activePuzzle && !this.vsEngine) {
                Game.analysisChess.load(this.activePuzzle.fen);
                GUI.board.position(this.activePuzzle.fen);
            }
        }, 1000); 
    },

    next: function() {
        if (this.currentIdx < Game.puzzles.length - 1) this.showPuzzle(this.currentIdx + 1);
        else GUI.showToast("Last puzzle completed!", "success");
    },
    
    prev: function() {
        if (this.currentIdx > 0) this.showPuzzle(this.currentIdx - 1);
    },
    
    skip: function() {
        if (this.currentIdx < Game.puzzles.length - 1) this.showPuzzle(this.currentIdx + 1);
    }
};

/**
 * GUI & INTERACTION
 */
const GUI = {
    board: null,
    settingsModal: null,
    hintState: 0, 
    showEvalInPlay: true,
    
    init: function() {
        const savedOverrideId = localStorage.getItem('activeDataUserId');

        if (firebaseConfig) {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    authUserId = user.uid;
                    log(`Firebase: Authenticated as ${authUserId.substring(0, 8)}...`);
                    
                    if (savedOverrideId) {
                        activeDataUserId = savedOverrideId;
                        log(`Using saved profile ID: ${activeDataUserId.substring(0, 8)}...`);
                    } else {
                        activeDataUserId = authUserId;
                    }
                    
                    document.getElementById('dataProfileBadge').innerText = `Profile: ${activeDataUserId.substring(0, 8)}...`;
                    Game.loadFromStorage(); 
                } else {
                    try {
                        log("Firebase: Attempting sign-in...");
                        if (typeof __initial_auth_token !== 'undefined') {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (e) {
                        log("Firebase Auth Error: " + e.message, 'ERROR');
                        // Fallback in case of auth failure
                        activeDataUserId = crypto.randomUUID();
                        document.getElementById('dataProfileBadge').innerText = `Profile: Local (${activeDataUserId.substring(0, 8)}...)`;
                        Game.loadFromStorage();
                    }
                }
            });
        } else {
            log("Firebase config not found. App cannot save data.", 'WARN');
            activeDataUserId = 'anonymous_local'; 
            document.getElementById('dataProfileBadge').innerText = `Profile: Local (${activeDataUserId.substring(0, 8)}...)`;
        }
        
        this.board = Chessboard('board', {
            draggable: true,
            position: 'start',
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
            onDragStart: (src, p) => {
                Game.selectedSquare = null;
                $('.square-55d63').removeClass('highlight-selected');

                if (Game.mode === 'analysis' || Game.mode === 'archive') return false; 
                if (Game.mode === 'play' && Game.playViewIndex !== -1) return false; 
                
                const chess = Game.getActiveChess();
                const turnColor = chess.turn(); 
                const pieceColor = p.charAt(0); 
                
                if (Game.mode === 'play' || Game.mode === 'puzzles') {
                    if (pieceColor !== Game.playUserColor && Game.mode === 'play') return false; 
                    if (chess.turn() !== pieceColor) return false; 
                    if (chess.game_over()) return false;
                }

                if (turnColor !== pieceColor) return false;
                return true;
            },
            onDrop: async (src, tgt) => {
                if (src === tgt) return;
                
                if (Game.mode === 'play' && Game.playViewIndex !== -1) return 'snapback';

                if (Game.mode === 'puzzles' || Game.mode === 'archive') {
                    return await PuzzleManager.handleDrop(src, tgt);
                } else {
                    const res = Game.move(src, tgt);
                    return res ? undefined : 'snapback';
                }
            }
        });

        // TAP TO MOVE HANDLER
        $('#board').on('click', '.square-55d63', function(e) {
            e.preventDefault();
            const square = $(this).attr('data-square');
            GUI.handleSquareClick(square);
        });

        window.addEventListener('resize', () => {
             this.board.resize();
             if (window.innerWidth <= 768) document.getElementById('sidebar').classList.add('collapsed');
        });
        
        Engine.init();
        PuzzleManager.init();
        this.settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
        
        const k = localStorage.getItem('gemini_api_key');
        if(k) document.getElementById('apiKeyInput').value = k;
        
        this.showEvalInPlay = document.getElementById('showEvalToggle').checked;
        this.updateEloLabel(5);
        
        this.setupDraggableControls();
        
        // Mobile Init
        if (window.innerWidth <= 768) document.getElementById('sidebar').classList.add('collapsed');
    },
    
    setupDraggableControls: function() {
        const controls = document.getElementById('verticalAnalysisControls');
        let isDragging = false;
        let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

        // Apply necessary initial styles for dragging
        controls.style.position = 'fixed'; 
        controls.style.cursor = 'grab';
        
        const savedPos = JSON.parse(localStorage.getItem('controlPos') || '{}');
        const defaultLeft = 20; 
        const defaultTop = 200;

        if (savedPos.x !== undefined) {
            xOffset = savedPos.x;
            yOffset = savedPos.y;
            controls.style.left = xOffset + 'px';
            controls.style.top = yOffset + 'px';
            controls.style.right = 'initial';
            controls.style.bottom = 'initial';
        } else {
             // Default position for first time load
             xOffset = defaultLeft;
             yOffset = defaultTop;
             controls.style.left = xOffset + 'px';
             controls.style.top = yOffset + 'px';
        }
        if (savedPos.orientation === 'landscape') {
            controls.classList.add('landscape');
        }

        const dragStart = (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'I') return; // Don't drag if clicking buttons
            
            isDragging = true;
            controls.style.cursor = 'grabbing';

            // Ensure coordinates are relative to the viewport top/left
            const rect = controls.getBoundingClientRect();
            controls.style.left = rect.left + 'px';
            controls.style.top = rect.top + 'px';
            controls.style.right = 'initial';
            controls.style.bottom = 'initial';

            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                e.preventDefault(); 
            }
        };

        const drag = (e) => {
            if (!isDragging) return;

            if (e.type === "touchmove") {
                currentX = e.touches[0].clientX - initialX;
                currentY = e.touches[0].clientY - initialY;
            } else {
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
            }

            xOffset = currentX;
            yOffset = currentY;

            controls.style.left = currentX + 'px';
            controls.style.top = currentY + 'px';
        };

        const dragEnd = () => {
            if (!isDragging) return;
            isDragging = false;
            controls.style.cursor = 'grab';
            
            // Save new position
            localStorage.setItem('controlPos', JSON.stringify({
                x: xOffset,
                y: yOffset,
                orientation: controls.classList.contains('landscape') ? 'landscape' : 'portrait'
            }));
        };

        controls.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        controls.addEventListener('touchstart', dragStart);
        document.addEventListener('touchmove', drag);
        controls.addEventListener('touchend', dragEnd);

        // Add orientation toggle button inside the controls
        const toggleBtn = document.createElement('button');
        toggleBtn.innerHTML = '<i class="fa-solid fa-arrows-left-right"></i>';
        toggleBtn.title = 'Toggle Orientation';
        toggleBtn.onclick = (e) => {
            e.stopPropagation();
            controls.classList.toggle('landscape');
            dragEnd(); // Save new orientation
            // Adjust position slightly after flip if needed, but rely on saved coordinates
        };

        const separator = controls.querySelector('div[style*="height: 1px"]');
        if (separator) {
            controls.appendChild(toggleBtn);
            controls.insertBefore(toggleBtn, separator.nextSibling); 
        } else {
            controls.appendChild(toggleBtn);
        }
    },


    handleSquareClick: function(square) {
        if (Game.mode === 'analysis' || Game.mode === 'archive') return; 
        if (Game.mode === 'play' && Game.playViewIndex !== -1) return; 

        const chess = Game.getActiveChess();
        const turn = chess.turn();
        const piece = chess.get(square);
        
        if (chess.game_over()) return; 

        // State 1: Select Piece
        if (!Game.selectedSquare) {
            if (piece && piece.color === turn) {
                if (Game.mode === 'play' || Game.mode === 'puzzles') {
                     if (piece.color !== Game.playUserColor && Game.mode === 'play') return;
                     if (chess.turn() !== piece.color) return; 
                }
                
                Game.selectedSquare = square;
                $('.square-55d63').removeClass('highlight-selected');
                $('.square-' + square).addClass('highlight-selected');
            }
            return;
        }

        // State 2: Move or Reselect
        const source = Game.selectedSquare;
        
        if (source === square) {
            Game.selectedSquare = null;
            $('.square-55d63').removeClass('highlight-selected');
            return;
        }

        if (piece && piece.color === turn) {
             if (Game.mode === 'play' && piece.color !== Game.playUserColor) {
             } else {
                 Game.selectedSquare = square;
                 $('.square-55d63').removeClass('highlight-selected');
                 $('.square-' + square).addClass('highlight-selected');
                 return;
             }
        }

        // Attempt Move
        if (Game.mode === 'puzzles' || Game.mode === 'archive') {
             PuzzleManager.handleDrop(source, square).then(res => {
                 if (res !== 'snapback') {
                     GUI.board.position(Game.analysisChess.fen());
                 }
             });
        } else {
            Game.move(source, square);
        }
        
        // Clear selection regardless of success for tap-to-move
        Game.selectedSquare = null;
        $('.square-55d63').removeClass('highlight-selected');
    },
    
    showToast: function(message, type = 'success') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `custom-toast ${type}`;
        
        let icon = type === 'success' ? '<i class="fa-solid fa-circle-check fa-lg text-success"></i>' : '<i class="fa-solid fa-triangle-exclamation fa-lg text-warning"></i>';
        
        toast.innerHTML = `${icon} <span>${message}</span>`;
        container.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 100);
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    },

    updateEloLabel: function(val) {
        const elo = 800 + (val * 120);
        document.getElementById('eloLabel').innerText = `ELO: ~${elo}`;
    },

    toggleSettings: function() {
        document.getElementById('dataProfileIdInput').value = activeDataUserId;
        document.getElementById('currentActiveDataId').innerText = activeDataUserId;
        this.settingsModal.show(); 
    },

    updateDataProfile: function() {
        const newId = document.getElementById('dataProfileIdInput').value.trim();
        if (newId && newId !== activeDataUserId) {
            activeDataUserId = newId;
            localStorage.setItem('activeDataUserId', newId);
            document.getElementById('dataProfileBadge').innerText = `Profile: ${activeDataUserId.substring(0, 8)}... (Override)`;
            document.getElementById('currentActiveDataId').innerText = activeDataUserId;
            Game.loadFromStorage();
            GUI.showToast(`Profile switched to ${newId.substring(0, 8)}... Reloading data.`, "success");
        } else if (!newId && authUserId) {
            // Revert to authenticated user
             activeDataUserId = authUserId;
             localStorage.removeItem('activeDataUserId');
             document.getElementById('dataProfileBadge').innerText = `Profile: ${activeDataUserId.substring(0, 8)}...`;
             document.getElementById('currentActiveDataId').innerText = activeDataUserId;
             Game.loadFromStorage();
             GUI.showToast("Profile reset to authenticated user.", "success");
        }
    },

    switchTab: function(mode) {
        Game.mode = mode;
        Engine.stop();
        
        Game.playViewIndex = -1;
        document.getElementById('boardCard').classList.remove('opacity-50');

        this.updateEval(0, null); 
        document.getElementById('wdlValue').innerText = "Win: 50%"; 

        document.getElementById('board').classList.remove('opacity-50');
        document.querySelectorAll('.mode-tab').forEach(el => el.classList.remove('active'));
        
        const mainBoardPanel = document.getElementById('mainBoardPanel');
        const puzzleArchivePanel = document.getElementById('puzzleArchivePanel');

        if (mode === 'analysis') document.getElementById('tab-analysis').classList.add('active');
        else if (mode === 'puzzles') document.getElementById('tab-puzzles').classList.add('active');
        else if (mode === 'archive') document.getElementById('tab-archive').classList.add('active');
        else document.getElementById('tab-play').classList.add('active');
        
        this.clearArrows();
        this.resetHint();

        const analysisIds = ['analysisControls', 'analysisPanel', 'scanBtn', 'verticalAnalysisControls'];
        const puzzleIds = ['puzzleControls', 'puzzleStatusHeader', 'puzzleFeedback', 'puzzleEngineContainer'];
        const playIds = ['playControls'];

        const hideAll = (ids) => ids.forEach(id => document.getElementById(id)?.classList.add('d-none'));
        const showAll = (ids) => ids.forEach(id => document.getElementById(id)?.classList.remove('d-none'));
        
        hideAll(analysisIds); hideAll(puzzleIds); hideAll(playIds);
        document.getElementById('analysisPanel').classList.add('hidden'); 
        mainBoardPanel.classList.remove('d-none');
        puzzleArchivePanel.classList.add('d-none');
        
        const header = document.getElementById('boardHeaderContainer');

        if (mode === 'analysis') {
            header.classList.add('d-none');
            showAll(['analysisPanel', 'scanBtn', 'verticalAnalysisControls']); 
            document.getElementById('analysisPanel').classList.remove('hidden');
            
            Game.analysisChess.reset();
            for(let i=0; i<=Game.index; i++) {
                 if(Game.history[i]) Game.analysisChess.move(Game.history[i].san);
            }
            this.board.position(Game.analysisChess.fen());
            this.update(); 
            this.board.orientation(Game.userColor === 'b' ? 'black' : 'white');
            document.getElementById('gameTitle').innerText = "Game Analysis";
        } 
        else if (mode === 'puzzles') {
            header.classList.remove('d-none'); 
            showAll(puzzleIds);
            PuzzleManager.loadPuzzles();
            document.getElementById('gameTitle').innerText = "Tactical Puzzles";
        }
        else if (mode === 'archive') {
            header.classList.add('d-none');
            mainBoardPanel.classList.add('d-none');
            puzzleArchivePanel.classList.remove('d-none');
        }
        else if (mode === 'play') {
            header.classList.remove('d-none');
            showAll(playIds);
            this.board.position(Game.playChess.fen());
            this.update(); 
            this.board.orientation(Game.playUserColor === 'w' ? 'white' : 'black');
            document.getElementById('gameTitle').innerText = "Vs Stockfish";
        }
        this.updateMaterial();
        setTimeout(() => this.board.resize(), 100);
    },
    
    toggleLogs: function(show) { document.getElementById('logPanel').classList.toggle('hidden', !show); },
    toggleEvalBar: function(show) { 
        this.showEvalInPlay = show;
        this.updateEvalDisplayVisibility();
    },

    updateEvalDisplayVisibility: function() {
        const container = document.getElementById('boardCard');
        if (Game.mode === 'play' && !this.showEvalInPlay) {
            container.classList.add('play-mode-blind');
        } else {
            container.classList.remove('play-mode-blind');
        }
    },

    toggleSidebar: function() {
        document.getElementById('sidebar').classList.toggle('collapsed');
        setTimeout(() => this.board.resize(), 300);
    },

    flip: function(mode) {
        if (mode === 'play') {
            Engine.stop(); 
            
            Game.playUserColor = Game.playUserColor === 'w' ? 'b' : 'w';
            this.board.orientation(Game.playUserColor === 'w' ? 'white' : 'black');
            
            if (Game.playChess.turn() !== Game.playUserColor && !Game.playChess.game_over()) {
                document.getElementById('boardCard').classList.add('opacity-50'); 
                Engine.playResponse(Game.playChess.fen());
            } else {
                 document.getElementById('boardCard').classList.remove('opacity-50'); 
            }
        } else {
            this.board.flip();
        }
        this.clearArrows();
    },

    resetGame: function() {
        Game.playChess.reset();
        Game.playUserColor = 'w';
        Game.playViewIndex = -1; 
        this.board.orientation('white');
        document.getElementById('checkmateOverlay').classList.add('d-none');
        document.getElementById('boardCard').classList.remove('opacity-50'); 
        GUI.update();
        Engine.analyze(Game.playChess.fen());
        GUI.showToast("New game started!", "success");
    },

    undoPlayMove: function() {
        Game.playChess.undo(); 
        Game.playChess.undo(); 
        Game.playViewIndex = -1; 
        document.getElementById('boardCard').classList.remove('opacity-50'); 
        GUI.update();
        Engine.analyze(Game.playChess.fen());
    },

    update: function() {
        const chess = Game.getActiveChess(); 
        this.board.position(chess.fen());
        this.resetHint();
        this.clearArrows();
        this.updateMaterial();
        this.updateEvalDisplayVisibility(); 
        
        if (Game.mode !== 'analysis') {
            if(Game.mode === 'play' && Game.playViewIndex === -1) {
                 Engine.analyze(Game.playChess.fen()); 
            }
            return;
        }

        // ANALYSIS UPDATE
        const moveIdx = Game.index; 
        const ply = moveIdx + 1; 

        const display = document.getElementById('coachDisplay');
        let commentData = Gemini.comments[ply.toString()];
        const analysisItem = Game.analysisData[moveIdx];
        
        display.className = "coach-display"; 
        if(analysisItem) display.classList.add(analysisItem.classification);

        if (commentData) {
            let html = `<div><strong>${analysisItem.classification}</strong>. ${marked.parse(commentData.analysis)}</div>`;
            if (commentData.pv_explanation && commentData.pv_explanation.length > 0) {
                html += `<div class="mt-2 text-muted small border-top pt-2"><strong><i class="fa-solid fa-list-ol"></i> Plan:</strong><ul>`;
                commentData.pv_explanation.forEach(line => html += `<li>${line}</li>`);
                html += `</ul></div>`;
            }
            display.innerHTML = html;
        } else if (analysisItem) {
             display.innerHTML = `<div><strong>${analysisItem.classification}</strong>. ${analysisItem.bestMoveSan ? `Missed <span class="badge bg-success">${analysisItem.bestMoveSan}</span>.` : ''}</div>
             <div class="mt-3 text-muted small"><i class="fa-solid fa-microchip"></i> Engine Best: ${analysisItem.bestMoveSan}</div>
             `;
        }
    },
    
    updateMaterial: function() {
        const chess = Game.mode === 'puzzles' || Game.mode === 'archive' ? Game.analysisChess : Game.getActiveChess();
        const board = chess.board();
        
        const fullSet = { p:8, n:2, b:2, r:2, q:1, k:1 };
        let currentCounts = { w: {p:0,n:0,b:0,r:0,q:0,k:0}, b: {p:0,n:0,b:0,r:0,q:0,k:0} };
        
        for(let r=0; r<8; r++){
            for(let c=0; c<8; c++){
                const p = board[r][c];
                if(p) currentCounts[p.color][p.type]++;
            }
        }
        
        const icons = { p: '', n: '', b: '', r: '', q: '', k: '' }; 
        const getGraveyard = (colorOfPiecesCaptured) => {
            let s = "";
            ['q','r','b','n','p'].forEach(type => {
                let capturedCount = fullSet[type] - currentCounts[colorOfPiecesCaptured][type];
                if(capturedCount > 0) {
                    for(let i=0; i<capturedCount; i++) s += `<span class="ms-1">${icons[type]}</span>`;
                }
            });
            return s;
        }
        
        document.getElementById('matWhite').innerHTML = getGraveyard('b');
        document.getElementById('matBlack').innerHTML = getGraveyard('w');
    },

    resetCoachDisplay: function() {
        document.getElementById('coachDisplay').innerHTML = `<div class="text-center text-muted" style="margin-top:20px"><i class="fa-solid fa-chess"></i><br>Ready.</div>`;
    },
    
    updateEval: function(cp, mate) {
        let valText = "0.00";
        let pct = 50;
        let winPct = 50;
        
        if (mate !== null) {
            valText = `M${Math.abs(mate)}`;
            pct = mate > 0 ? 100 : 0;
            winPct = mate > 0 ? 100 : 0;
        } else {
            valText = (cp / 100).toFixed(2);
            if(cp > 0) valText = "+" + valText;
            let val = Math.max(-500, Math.min(500, cp));
            pct = 50 + (val / 10);
            winPct = 100 / (1 + Math.pow(10, -(cp / 400)));
        }
        
        document.getElementById('evalValue').innerText = valText;
        document.getElementById('evalFill').style.width = pct + '%';
        document.getElementById('wdlValue').innerText = `Win: ${Math.round(winPct)}%`;
    },

    hint: async function() {
        const fen = Game.getActiveChess().fen();
        const best = await Engine.getBestMove(fen);
        if(!best) return;
        const from = best.substring(0,2);
        const to = best.substring(2,4);

        if (this.hintState === 0) {
            $('.square-55d63').removeClass('highlight-hint');
            $('.square-' + from).addClass('highlight-hint');
            this.hintState = 1;
        } else {
            this.drawArrow(from, to, '#22c55e');
            this.hintState = 0;
        }
    },
    
    showBestMove: async function() {
        const fen = Game.getActiveChess().fen();
        const best = await Engine.getBestMove(fen);
        if(!best) return;
        const from = best.substring(0,2);
        const to = best.substring(2,4);
        
        this.clearArrows();
        this.drawArrow(from, to, '#22c55e');
        
        $('.square-' + from).addClass('highlight-hint');
        setTimeout(() => $('.square-' + from).removeClass('highlight-hint'), 1500);
    },
    
    resetHint: function() {
        this.hintState = 0;
        $('.square-55d63').removeClass('highlight-hint');
    },
    
    drawArrow: function(from, to, color) {
        const $board = $('#board');
        const boardWidth = $board.width();
        const sqSize = boardWidth / 8;
        const orientation = this.board.orientation();
        const cols = 'abcdefgh';
        const rows = '87654321';
        const getCoords = (sq) => {
            let c = cols.indexOf(sq[0]);
            let r = rows.indexOf(sq[1]);
            if (orientation === 'black') { c = 7 - c; r = 7 - r; }
            return { x: c * sqSize + sqSize/2, y: r * sqSize + sqSize/2 };
        }
        const start = getCoords(from);
        const end = getCoords(to);
        const svg = document.getElementById('arrowOverlay');
        const markerId = 'reusableArrowHead'; 
        
        let defs = svg.querySelector('defs');
        if (!defs) {
            defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            svg.appendChild(defs);

            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', markerId);
            marker.setAttribute('markerWidth', '4');
            marker.setAttribute('markerHeight', '4');
            marker.setAttribute('refX', '2');
            marker.setAttribute('refY', '2');
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,0 L4,2 L0,4 Z');
            marker.appendChild(path);
            defs.appendChild(marker);
        }
        
        defs.querySelector(`#${markerId} path`).setAttribute('fill', color);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', start.x);
        line.setAttribute('y1', start.y);
        line.setAttribute('x2', end.x);
        line.setAttribute('y2', end.y);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', sqSize * 0.15);
        line.setAttribute('opacity', '0.7');
        line.setAttribute('marker-end', `url(#${markerId})`); 
        
        svg.appendChild(line);
    },
    
    clearArrows: function() {
        const svg = document.getElementById('arrowOverlay');
        const defs = svg.querySelector('defs');

        let child = svg.lastChild;
        while (child) {
            const prev = child.previousSibling;
            if (child !== defs) {
                svg.removeChild(child);
            }
            child = prev;
        }
    },
    
    next: () => Game.nav('next'), prev: () => Game.nav('prev'), first: () => Game.nav('first'), last: () => Game.nav('last'),
    
    copyPGN: function() {
        const pgn = Game.getActiveChess().pgn();
        const ta = document.createElement('textarea');
        ta.value = pgn;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("PGN copied!", "success");
    },

    copyLogs: function() {
        if (!window.sys_logs || window.sys_logs.length === 0) {
            GUI.showToast("No logs to copy.", "error");
            return;
        }
        let logText = window.sys_logs.map(l => 
            `[${l.timestamp}] [${l.type}] ${l.message}`
        ).join('\n');
        
        const ta = document.createElement('textarea');
        ta.value = logText;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("System logs copied to clipboard.", "success");
    },
    
    copyAnalysis: function() {
        if (!Game.analysisData || Game.analysisData.length === 0) { GUI.showToast("No analysis available.", "error"); return; }
        let report = `Game Analysis\n\n`;
        Game.analysisData.forEach((d, i) => {
            report += `${i+1}. ${d.san} [${d.classification}] ${d.eval}\n`;
            if(Gemini.comments[i+1]) report += `Coach: ${Gemini.comments[i+1].analysis}\n`;
        });
        const ta = document.createElement('textarea');
        ta.value = report;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("Analysis copied!", "success");
    }
};

function importManualPGN() {
    const pgn = document.getElementById('pgnText').value;
    if(!pgn) return;
    const gameId = Date.now().toString(); 
    const newGame = { id: gameId, date: new Date().toISOString().substring(0, 10), opening: "Custom PGN", result: '?', accuracy: 0, pgn: pgn, oppRating: 0, userColor: 'white' };
    
    Game.saveGame(newGame); 

    document.getElementById('pgnModal').style.display='none';
    document.getElementById('pgnModal').classList.remove('show');
    GUI.showToast("PGN imported. Loading game...", "success");
}

document.getElementById('csvInput').onchange = (e) => { if(e.target.files.length) parseFile(e.target.files[0]); };
function parseFile(file) {
    GUI.showToast("Parsing CSV, please wait...", "info");
    Papa.parse(file, { header: true, skipEmptyLines: true, complete: (res) => {
        const newData = res.data.map((r, i) => {
            const gameId = Date.now().toString() + i;
            return {
                id: gameId, 
                date: r.date || new Date().toISOString().substring(0, 10), 
                opening: r.opening || 'Unknown Game ' + i,
                result: r.result || '-', 
                accuracy: parseFloat(r.userAccuracy) || 0,
                pgn: r.pgn || "", 
                oppRating: parseInt(r.opponentRating) || 0,
                userColor: (r.userColor || 'white').toLowerCase()
            };
        });
        
        newData.forEach(g => Game.saveGame(g));
        GUI.showToast(`${newData.length} games imported successfully.`, "success");
    }});
}

function renderList() {
    const list = document.getElementById('gameList'); 
    list.innerHTML = "";
    let arr = [...Game.data];
    const sort = document.getElementById('sortSelect').value;
    const search = document.getElementById('searchBox').value.toLowerCase();
    
    // Filter
    if (search) {
        arr = arr.filter(g => g.opening.toLowerCase().includes(search));
    }
    
    // Sort
    if(sort === 'recent') arr.sort((a,b) => b.id.localeCompare(a.id));
    else if(sort === 'oldest') arr.sort((a,b) => a.id.localeCompare(b.id));
    else if(sort === 'acc_high') arr.sort((a,b) => b.accuracy - a.accuracy);
    else if(sort === 'acc_low') arr.sort((a,b) => a.accuracy - b.accuracy);
    else if(sort === 'elo_high') arr.sort((a,b) => b.oppRating - a.oppRating);
    else if(sort === 'elo_low') arr.sort((a,b) => a.oppRating - b.oppRating);

    if (arr.length === 0) {
        list.innerHTML = `<div class="p-3 text-center text-muted small">No games found matching criteria.</div>`;
        return;
    }

    arr.forEach(g => {
        const div = document.createElement('div'); 
        div.className = "game-item rounded"; 
        div.id = "g-" + g.id;
        const colorClass = g.result==='win'?'text-success':(g.result==='loss'?'text-danger':'text-muted');
        div.innerHTML = `
            <div class="d-flex justify-content-between fw-bold">
                <span class="text-truncate" style="max-width:180px">${g.opening}</span>
                <span class="${colorClass}">${g.result.toUpperCase()}</span>
            </div>
            <div class="game-meta small text-muted">Acc: ${g.accuracy}%  Vs ${g.oppRating}  Color: ${g.userColor}</div>
            <div class="mt-1 d-flex justify-content-end">
                <button class="btn btn-sm btn-outline-danger" onclick="event.stopPropagation(); Game.deleteGame('${g.id}')" title="Delete Game">
                    <i class="fa-solid fa-trash-can fa-xs"></i>
                </button>
            </div>
        `;
        div.onclick = () => {
            document.querySelectorAll('.game-item').forEach(el => el.classList.remove('active'));
            div.classList.add('active');
            Game.load(g.id)
        }; 
        list.appendChild(div);
    });
}

window.onload = function() { 
    GUI.init();
    GUI.switchTab('analysis');
};

// --- FIX: Expose module-defined objects to the global window scope for HTML onclick handlers ---
window.GUI = GUI;
window.PuzzleManager = PuzzleManager;
window.Scanner = Scanner;
window.PuzzleArchive = PuzzleArchive; // Expose new object
window.importManualPGN = importManualPGN; // Expose global function
window.renderList = renderList; // Expose global function
</script>
</body>
</html>
