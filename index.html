<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Arena: Grandmaster Coach</title>
    
    <!-- Dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- CSS -->
    <style>
        /*! chessboard.js v1.0.0 | (c) 2019 Chris Oakman | MIT License chessboardjs.com/license */
        .clearfix-7da63 { clear: both; }
        .board-b72b1 { border: 2px solid #404040; box-sizing: content-box; }
        .board-b72b1 * { box-sizing: content-box; }
        .square-55d63 { float: left; position: relative; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; outline: 1px solid rgba(0,0,0,0.15); outline-offset: -1px; }
        .square-55d63:after, .square-55d63:before { display: table; content: " "; }
        .square-55d63:after { clear: both; }
        .piece-417db { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: pointer; z-index: 50; } 
        .alpha-d2270 { position: absolute; bottom: 1px; right: 3px; font-size: 11px; line-height: 12px; }
        .numeric-fc462 { position: absolute; top: 2px; left: 2px; font-size: 11px; cursor: default; line-height: 12px; }
        
        /* App Styles */
        body { background-color: #f1f5f9; font-family: 'Segoe UI', system-ui, sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .navbar { background: #1e1b4b; color: white; padding: 0.5rem 1rem; border-bottom: 1px solid #334155; flex-shrink: 0; z-index: 20; }
        .navbar-brand { color: white; font-weight: 700; font-size: 1.1rem; text-decoration: none; display: flex; align-items: center; gap: 10px; }
        .main-layout { display: flex; flex: 1; overflow: hidden; position: relative; }
        
        .sidebar { width: 320px; background: white; border-right: 1px solid #cbd5e1; display: flex; flex-direction: column; z-index: 10; flex-shrink: 0; transition: margin-left 0.3s ease; }
        .sidebar.collapsed { margin-left: -320px; }
        .sidebar-header { padding: 15px; border-bottom: 1px solid #e2e8f0; background: #f8fafc; display: flex; flex-direction: column; gap: 10px; }
        .game-list { flex: 1; overflow-y: auto; }
        .game-item { padding: 10px 15px; border-bottom: 1px solid #f1f5f9; cursor: pointer; transition: background 0.1s; font-size: 0.9rem; }
        .game-item:hover { background: #f1f5f9; }
        .game-item.active { background: #e0e7ff; border-left: 3px solid #4f46e5; }
        
        .content-area { flex: 1; display: flex; flex-direction: column; min-width: 0; background: #f8fafc; height: 100%; position: relative; }
        
        .mode-tabs { padding: 10px 10px 0 10px; background: #fff; border-bottom: 1px solid #cbd5e1; display: flex; gap: 5px; flex-shrink: 0; }
        .mode-tab { padding: 8px 16px; cursor: pointer; border-radius: 6px 6px 0 0; font-weight: 600; font-size: 0.9rem; color: #64748b; border: 1px solid transparent; border-bottom: none; display: flex; align-items: center; gap: 6px; }
        .mode-tab:hover { background: #f8fafc; color: #334155; }
        .mode-tab.active { background: #f8fafc; color: #1e1b4b; border-color: #cbd5e1; border-bottom: 1px solid #f8fafc; margin-bottom: -1px; z-index: 2; }
        
        .arena { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 20px 80px 20px 20px; overflow-y: auto; position: relative; min-height: 0; }
        .board-card { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); width: 100%; max-width: 560px; display: flex; flex-direction: column; gap: 10px; position: relative; transition: all 0.3s; z-index: 5; }
        
        .board-card.fullscreen-mode {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; max-width: none; z-index: 1000;
            padding: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; background: #1e1b4b;
        }
        .board-card.fullscreen-mode #board-wrapper { 
            height: 85vh; width: 85vh; 
            max-width: 95vw; max-height: 85vh; 
            margin: 0 auto; 
        }
        .board-card.fullscreen-mode #evalBar { display: none; }
        .board-card.fullscreen-mode .fullscreen-exit-btn { display: block; }
        .fullscreen-exit-btn { display: none; position: absolute; top: 20px; right: 20px; z-index: 1001; }
        
        #board-wrapper { position: relative; width: 100%; }
        #board { width: 100%; height: 100%; touch-action: none; z-index: 10; position: relative; }
        #arrowOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        .analysis-panel { 
            flex: 0 0 35vh; 
            min-height: 150px;
            max-height: 50vh;
            background: white; 
            border-top: 1px solid #cbd5e1; 
            display: flex; 
            flex-direction: row; 
            flex-shrink: 0; 
            transition: all 0.3s ease;
            position: relative;
            z-index: 20;
        }
        .analysis-moves { flex: 1; border-right: 1px solid #eee; display: flex; flex-direction: column; position: relative; }
        .analysis-logs { width: 40%; display: flex; flex-direction: column; background: #0f172a; color: #4ade80; font-family: monospace; font-size: 11px; transition: width 0.3s; position: relative; }
        .analysis-logs.hidden { display: none !important; }
        .analysis-panel.hidden { display: none !important; }
        
        .log-content { flex: 1; overflow-y: auto; padding: 5px; white-space: pre-wrap; word-break: break-word; }
        .log-entry-sys { margin-bottom: 2px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px; }
        .log-err { color: #ef4444; }
        .log-warn { color: #f59e0b; }
        
        #analysisListContainer { flex: 1; overflow-y: auto; padding: 0; background: #fff; }
        .analysis-mode-hidden { display: none !important; }

        .log-entry { padding: 6px 12px; border-bottom: 1px solid #f1f5f9; font-size: 0.85rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .log-entry:hover { background-color: #f8fafc; }
        .log-entry.active { background-color: #eef2ff; border-left: 4px solid #6366f1; }
        
        .move-class { font-size: 0.65rem; font-weight: 800; padding: 2px 6px; border-radius: 4px; color: white; text-transform: uppercase; letter-spacing: 0.5px; }
        .class-Brilliant { background-color: #1baca6; } .class-Great { background-color: #5c8bb0; } .class-Best { background-color: #96bc4b; } 
        .class-Excellent { background-color: #96bc4b; opacity: 0.8; } .class-Good { background-color: #96bc4b; opacity: 0.6; } 
        .class-Book { background-color: #d5a47d; } .class-Inaccuracy { background-color: #f0c15c; color: #5e4b1e; } 
        .class-Mistake { background-color: #e6912c; } .class-Blunder { background-color: #fa412d; } .class-Missed { background-color: #ff879c; } 
        .class-Neutral { background-color: #a3a3a3; } 

        .coach-display { padding: 15px; background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); border-bottom: 1px solid #e2e8f0; font-size: 0.95rem; color: #334155; min-height: 0; flex: 1; overflow-y: auto; position: relative; border-left: 4px solid #cbd5e1; }
        .coach-display.Brilliant { border-left-color: #1baca6; background: #e0f2f1; } .coach-display.Great { border-left-color: #5c8bb0; background: #e1f5fe; }
        .coach-display.Best { border-left-color: #96bc4b; background: #f1f8e9; } .coach-display.Excellent { border-left-color: #96bc4b; background: #f1f8e9; }
        .coach-display.Good { border-left-color: #96bc4b; background: #f9fbe7; } .coach-display.Book { border-left-color: #d5a47d; background: #fff3e0; }
        .coach-display.Inaccuracy { border-left-color: #f0c15c; background: #fffde7; } .coach-display.Mistake { border-left-color: #e6912c; background: #fff3e0; }
        .coach-display.Blunder { border-left-color: #fa412d; background: #ffebee; } .coach-display.Missed { border-left-color: #ff879c; background: #fce4ec; }

        .control-row { display: flex; justify-content: center; gap: 5px; margin-top: 5px; }
        .eval-bar-wrapper { width: 100%; height: 8px; background: #475569; border-radius: 4px; overflow: hidden; margin: 5px 0; transition: opacity 0.3s; position: relative; }
        .eval-fill { height: 100%; width: 50%; background: #22c55e; transition: width 0.3s ease-out; }
        .eval-container { transition: opacity 0.3s; }
        .play-mode-blind .eval-container { opacity: 0; pointer-events: none; }
        .material-stats { font-size: 0.9rem; font-weight: 600; color: #475569; display: flex; justify-content: space-between; padding: 6px 10px; background: #f8fafc; border-radius: 4px; margin-top: 5px; border: 1px solid #e2e8f0; }
        .mat-side { display: flex; gap: 2px; align-items: center; min-height: 20px; }
        .mat-label { font-size: 0.7em; text-transform: uppercase; color: #94a3b8; margin-right: 5px; }
        .graveyard-w { color: #000; font-size: 1.2em; display:flex; } .graveyard-b { color: #fff; text-shadow: 0 0 1px #000; font-size: 1.2em; display:flex; } 
        .puzzle-feedback { text-align: center; height: 30px; font-weight: bold; margin-top: 10px; }
        .text-correct { color: #16a34a; } .text-incorrect { color: #dc2626; }
        .puzzle-success { animation: pulse-green 1s; box-shadow: 0 0 15px #22c55e; } .puzzle-fail { animation: shake 0.5s; box-shadow: 0 0 15px #ef4444; }
        .highlight-select { box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.5); }
        .highlight-hint { box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.8) !important; background: rgba(255, 255, 0, 0.2); }
        .highlight-selected { box-shadow: inset 0 0 0 4px rgba(59, 130, 246, 0.8) !important; }
        .opacity-50 { opacity: 0.5; pointer-events: none; }
        .wdl-stats { font-size: 0.7rem; color: #64748b; text-align: center; margin-top: 2px; font-family: monospace; }
        
        #verticalAnalysisControls {
            position: absolute; right: 15px; top: 40%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 10px; z-index: 2000;
            background: rgba(255, 255, 255, 0.95); padding: 10px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border: 1px solid #cbd5e1;
        }
        #verticalAnalysisControls button {
            width: 42px; height: 42px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.2s;
            border: 1px solid #e2e8f0; background: white; color: #334155;
        }
        #verticalAnalysisControls button:hover { background: #f1f5f9; transform: scale(1.05); color: #0f172a; }
        #verticalAnalysisControls button:active { transform: scale(0.95); }
        #verticalAnalysisControls button:disabled { opacity: 0.5; cursor: not-allowed; background: #e2e8f0; }

        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        .checkmate-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 60; display: flex;
            justify-content: center; align-items: center; border-radius: 8px; pointer-events: none;
        }
        .checkmate-text {
            color: #ef4444; font-size: 3rem; font-weight: 900; text-transform: uppercase; text-shadow: 2px 2px 0 #fff; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .toast-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 9999; }
        .custom-toast {
            background: #334155; color: white; padding: 12px 24px; border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            display: flex; align-items: center; gap: 10px; font-weight: 500; opacity: 0; transform: translateY(20px); transition: all 0.3s ease;
        }
        .custom-toast.show { opacity: 1; transform: translateY(0); }
        .custom-toast.success { background: #065f46; }
        .custom-toast.error { background: #991b1b; }

        @media (max-width: 768px) {
            .sidebar { position: absolute; height: 100%; box-shadow: 5px 0 15px rgba(0,0,0,0.2); }
            .sidebar.collapsed { margin-left: -320px; }
            .arena { padding: 10px !important; }
            .board-card { width: 98% !important; max-width: none; }
            #verticalAnalysisControls { right: 5px; top: 50%; scale: 0.85; }
            .analysis-panel { flex: 0 0 40vh; }
            .analysis-logs { display: none !important; }
        }
    </style>
</head>
<body>

<!-- Navbar -->
<nav class="navbar d-flex justify-content-between align-items-center">
    <div class="d-flex align-items-center gap-3">
        <a class="navbar-brand" href="#"><i class="fa-solid fa-chess-knight fa-lg"></i> Chess Arena Pro</a>
        <span class="badge bg-secondary" id="engineStatus">Engine: Init...</span>
    </div>
    <div class="d-flex gap-2">
        <button class="btn btn-sm btn-outline-light" onclick="GUI.toggleSettings()">
            <i class="fa-solid fa-gear"></i>
        </button>
        <button class="btn btn-sm btn-outline-light" onclick="document.getElementById('pgnModal').classList.add('show'); document.getElementById('pgnModal').style.display='block'">
            <i class="fa-solid fa-file-import"></i> Paste PGN
        </button>
        <input type="file" id="csvInput" accept=".csv" class="d-none">
        <button class="btn btn-sm btn-primary" onclick="document.getElementById('csvInput').click()">
            <i class="fa-solid fa-upload me-1"></i> Upload CSV
        </button>
        <button class="btn btn-sm btn-secondary" onclick="GUI.toggleSidebar()" title="Toggle Games List">
            <i class="fa-solid fa-bars"></i>
        </button>
    </div>
</nav>

<div class="main-layout">
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <input type="text" id="searchBox" class="form-control form-control-sm" placeholder="Search opening...">
            <div class="d-flex gap-1">
                <select class="form-select form-select-sm" id="sortSelect" onchange="renderList()">
                    <option value="recent">Recent</option>
                    <option value="oldest">Oldest</option>
                    <option value="acc_high">Accuracy (High)</option>
                    <option value="acc_low">Accuracy (Low)</option>
                    <option value="elo_high">Opp. ELO (High)</option>
                    <option value="elo_low">Opp. ELO (Low)</option>
                </select>
            </div>
        </div>
        <div class="game-list" id="gameList">
            <div class="p-3 text-center text-muted small">Upload CSV or PGN to load games</div>
        </div>
    </div>

    <div class="content-area">
        <div class="mode-tabs">
            <div class="mode-tab active" id="tab-analysis" onclick="GUI.switchTab('analysis')">
                <i class="fa-solid fa-magnifying-glass me-1"></i> Pro Analysis
            </div>
            <div class="mode-tab" id="tab-puzzles" onclick="GUI.switchTab('puzzles')">
                <i class="fa-solid fa-puzzle-piece me-1"></i> Smart Puzzles <span id="puzzleBadge" class="badge bg-danger rounded-pill ms-1 d-none">0</span>
            </div>
            <div class="mode-tab" id="tab-play" onclick="GUI.switchTab('play')">
                <i class="fa-solid fa-robot me-1"></i> Computer Play
            </div>
        </div>

        <div id="verticalAnalysisControls" class="d-none">
            <button onclick="GUI.first()" title="First Move"><i class="fa-solid fa-backward-step"></i></button>
            <button onclick="GUI.prev()" title="Previous Move"><i class="fa-solid fa-chevron-left"></i></button>
            <button onclick="GUI.next()" title="Next Move"><i class="fa-solid fa-chevron-right"></i></button>
            <button onclick="GUI.last()" title="Last Move"><i class="fa-solid fa-forward-step"></i></button>
            <div style="height: 1px; background: #e2e8f0; margin: 2px 5px;"></div>
            <button onclick="GUI.showBestMove()" title="Show Best Move" class="text-primary"><i class="fa-solid fa-star"></i></button>
            <button onclick="GUI.flip()" title="Flip Board"><i class="fa-solid fa-retweet"></i></button>
        </div>

        <div class="arena">
            <div class="board-card" id="boardCard">
                <button class="btn btn-danger btn-sm fullscreen-exit-btn" onclick="GUI.toggleFullscreen()"><i class="fa-solid fa-compress"></i> Exit</button>
                
                <div class="d-flex justify-content-between align-items-center mb-2" id="boardHeaderContainer">
                    <div id="boardHeaderLeft">
                        <strong id="gameTitle" class="text-truncate d-block" style="max-width: 250px;">Practice Board</strong>
                    </div>
                    <div id="puzzleStatusHeader" class="d-none flex-grow-1 text-center">
                        <span class="badge bg-warning text-dark" id="puzzleCountBadge">Puzzle 0/0</span>
                    </div>
                    <div class="d-flex align-items-center gap-2" id="boardHeaderRight">
                        <button class="btn btn-xs btn-outline-secondary" onclick="GUI.toggleFullscreen()" title="Fullscreen"><i class="fa-solid fa-expand"></i></button>
                        <div class="form-check form-switch m-0 d-none" id="puzzleEngineContainer">
                            <input class="form-check-input" type="checkbox" id="puzzleVsEngine" onchange="PuzzleManager.toggleEngineMode()">
                            <label class="form-check-label small fw-bold" for="puzzleVsEngine">Vs Engine</label>
                        </div>
                    </div>
                </div>

                <div id="board-wrapper">
                    <div id="board"></div>
                    <svg id="arrowOverlay"></svg>
                    <div id="checkmateOverlay" class="checkmate-overlay d-none">
                        <div class="checkmate-text">CHECKMATE</div>
                    </div>
                </div>
                
                <div id="evalContainer" class="eval-container">
                    <div class="eval-bar-wrapper" id="evalBar">
                        <div class="eval-fill" id="evalFill"></div>
                    </div>
                    <div class="d-flex justify-content-between small text-muted px-1" id="evalTextContainer">
                        <span id="evalValue">0.00</span>
                        <span id="wdlValue" class="wdl-stats">Win: 50%</span>
                    </div>
                </div>
                
                <div class="material-stats" id="materialDisplay">
                    <div class="mat-side"><span class="mat-label">W Captured:</span><div class="graveyard-w" id="matWhite"></div></div>
                    <div class="mat-side"><span class="mat-label">B Captured:</span><div class="graveyard-b" id="matBlack"></div></div>
                </div>

                <div id="puzzleFeedback" class="puzzle-feedback d-none"></div>

                <!-- Analysis Controls (Hidden but ID needed for logic) -->
                <div id="analysisControls" class="d-none"><div class="control-row"></div></div>

                <div id="puzzleControls" class="d-none">
                    <div class="control-row">
                        <button class="btn btn-sm btn-outline-secondary w-25" onclick="PuzzleManager.prev()" title="Previous Puzzle"><i class="fa-solid fa-chevron-left"></i></button>
                        <button class="btn btn-sm btn-secondary w-50" onclick="PuzzleManager.skip()">Skip</button>
                        <button class="btn btn-sm btn-outline-secondary w-25" onclick="PuzzleManager.next()" title="Next Puzzle"><i class="fa-solid fa-chevron-right"></i></button>
                    </div>
                    <div class="control-row mt-2">
                         <button class="btn btn-sm btn-success w-100" onclick="GUI.hint()"><i class="fa-solid fa-lightbulb"></i> Hint</button>
                    </div>
                </div>

                <div id="playControls" class="d-none">
                      <div class="control-row">
                        <button class="btn btn-sm btn-outline-secondary" onclick="GUI.prev()"><i class="fa-solid fa-chevron-left"></i></button>
                        <button class="btn btn-sm btn-outline-secondary" onclick="GUI.next()"><i class="fa-solid fa-chevron-right"></i></button>
                        <button class="btn btn-sm btn-dark" onclick="GUI.flip('play')"><i class="fa-solid fa-retweet"></i> Flip Side</button>
                    </div>
                    <div class="control-row">
                         <button class="btn btn-sm btn-warning w-50" onclick="GUI.undoPlayMove()"><i class="fa-solid fa-rotate-left"></i> Undo</button>
                         <button class="btn btn-sm btn-danger w-50" onclick="GUI.resetGame()"><i class="fa-solid fa-trash-can"></i> Reset</button>
                    </div>
                      <div class="control-row">
                         <button class="btn btn-sm btn-outline-secondary w-100" onclick="GUI.copyPGN()"><i class="fa-solid fa-copy"></i> PGN</button>
                    </div>
                    <div class="mt-3 pt-2 border-top">
                        <div class="d-flex justify-content-between">
                            <label class="small fw-bold text-muted">Stockfish Strength</label>
                            <span class="badge bg-primary" id="eloLabel">ELO: 1200</span>
                        </div>
                        <input type="range" class="form-range" min="0" max="20" value="5" id="skillRange" oninput="GUI.updateEloLabel(this.value); Engine.setSkill(this.value)">
                    </div>
                </div>

            </div>
        </div>

        <div class="analysis-panel" id="analysisPanel">
            <div class="analysis-moves">
                <div class="sidebar-header d-flex justify-content-between align-items-center bg-light">
                    <strong>Analysis Report</strong>
                    <div class="d-flex gap-1">
                        <select id="analysisFocus" class="form-select form-select-sm" style="width: 80px;">
                            <option value="both">Both</option>
                            <option value="w">White</option>
                            <option value="b">Black</option>
                        </select>
                        <button class="btn btn-sm btn-outline-dark" onclick="GUI.copyAnalysis()" title="Copy Full Analysis">
                             <i class="fa-solid fa-copy"></i>
                        </button>
                        <button class="btn btn-sm btn-primary" id="scanBtn" onclick="Scanner.start()">
                            <i class="fa-solid fa-wand-magic-sparkles me-1"></i> Full Analysis
                        </button>
                    </div>
                </div>
                
                <!-- RELATIVE POSITION PROGRESS BAR (Fixes Cut-off Issue) -->
                <div class="p-2 bg-light border-bottom d-none" id="scanProgress">
                    <div class="progress" style="height: 5px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" id="scanBar" style="width: 0%"></div>
                    </div>
                    <div class="text-center small text-muted mt-1" id="scanText">Analyzing...</div>
                </div>

                <div class="coach-display" id="coachDisplay">
                    <div class="text-center text-muted" style="margin-top: 20px;">
                        <i class="fa-solid fa-user-graduate fa-2x mb-2"></i><br>
                        Ready for analysis. Press "Full Analysis" to get insights.
                    </div>
                </div>

                <div id="analysisListContainer">
                      <div class="log-container" id="analysisList">
                        <div class="text-center text-muted mt-5 small">Select a game to start.</div>
                    </div>
                </div>
            </div>
            
            <div class="analysis-logs hidden" id="logPanel">
                <div class="p-2 border-bottom border-secondary bg-dark text-white small d-flex justify-content-between align-items-center">
                    <strong>System Log</strong>
                    <button class="btn btn-xs btn-outline-light" onclick="GUI.copyLogs()" title="Copy Logs"><i class="fa-solid fa-copy"></i></button>
                </div>
                <div class="log-content" id="sysLog">System Initialized.</div>
            </div>
        </div>

    </div>
</div>

<!-- TOAST CONTAINER -->
<div class="toast-container" id="toastContainer"></div>

<!-- MODALS -->
<div class="modal fade" id="settingsModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Settings</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="showEvalToggle" checked onchange="GUI.toggleEvalBar(this.checked)">
            <label class="form-check-label" for="showEvalToggle">Show Eval Bar (Computer Play)</label>
        </div>
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="showLogsSwitch" onchange="GUI.toggleLogs(this.checked)">
            <label class="form-check-label" for="showLogsSwitch">Show System Logs</label>
        </div>
        <hr>
        <div class="mb-3">
            <label class="form-label small fw-bold">Gemini API Key</label>
            <input type="password" id="apiKeyInput" class="form-control form-control-sm" placeholder="Paste Key Here...">
            <button class="btn btn-sm btn-outline-primary mt-2" onclick="localStorage.setItem('gemini_api_key', document.getElementById('apiKeyInput').value); alert('Key Saved!')">Save Key</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="pgnModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Paste PGN</h5>
        <button type="button" class="btn-close" onclick="document.getElementById('pgnModal').style.display='none'; document.getElementById('pgnModal').classList.remove('show')"></button>
      </div>
      <div class="modal-body">
        <textarea id="pgnText" class="form-control" rows="8" placeholder="[Event ...] 1. e4 e5 ..."></textarea>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" onclick="importManualPGN()">Import Game</button>
      </div>
    </div>
  </div>
</div>

<!-- SCRIPTS -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
// --- CONFIG ---
const STOCKFISH_URL = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
const MODEL_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent';
const apiKey = ""; 

/**
 * UTILITIES
 */
function log(msg, type = 'info') {
    const box = document.getElementById('sysLog');
    const time = new Date().toLocaleTimeString().split(' ')[0];
    const div = document.createElement('div');
    div.className = 'log-entry-sys';
    if(type === 'error') div.classList.add('log-err');
    if(type === 'warn') div.classList.add('log-warn');
    
    div.innerText = `[${time}] ${msg}`;
    box.appendChild(div);
    box.scrollTop = box.scrollHeight;
    
    if(!window.sys_logs) window.sys_logs = [];
    window.sys_logs.push(`[${time}] [${type.toUpperCase()}] ${msg}`);
}

function getEffectiveKey() {
    if(apiKey && apiKey.length > 0) return apiKey;
    return localStorage.getItem('gemini_api_key') || "";
}

/**
 * ENGINE (Stockfish)
 */
const Engine = {
    worker: null,
    isReady: false,
    isThinking: false,
    
    init: function() {
        log("Loading Stockfish 10.0.2...");
        try {
            const blob = new Blob([`importScripts('${STOCKFISH_URL}');`], {type: 'application/javascript'});
            this.worker = new Worker(URL.createObjectURL(blob));
            this.worker.postMessage('uci');
            this.worker.postMessage('setoption name UCI_ShowWDL value true'); 
            this.worker.onmessage = (e) => this.handleMessage(e.data);
            this.worker.onerror = (e) => {
                log("Engine Worker Error: " + e.message, 'error');
                document.getElementById('engineStatus').className = "badge bg-danger";
                document.getElementById('engineStatus').innerText = "Failed";
            };
        } catch(e) { 
            log("Engine Init Error: " + e, 'error'); 
            document.getElementById('engineStatus').className = "badge bg-danger";
            document.getElementById('engineStatus').innerText = "Failed";
        }
    },

    handleMessage: function(line) {
        if(line === 'uciok') {
            this.isReady = true;
            document.getElementById('engineStatus').className = "badge bg-success";
            document.getElementById('engineStatus').innerText = "Ready";
            log("Stockfish Ready.");
        }
    },

    setSkill: function(val) {
        if(!this.isReady) return;
        this.worker.postMessage(`setoption name Skill Level value ${val}`);
        const err = Math.max(0, 20 - val) * 20;
        this.worker.postMessage(`setoption name Skill Level Probability value ${err}`);
    },

    stop: function() {
        if(this.isReady) {
            this.worker.postMessage('stop');
            this.isThinking = false;
        }
    },

    runScan: function(fen) {
        return new Promise(resolve => {
            if(!this.isReady) {
                resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null });
                return;
            }
            
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;

            // Shorter timeout for faster scan
            const tId = setTimeout(() => {
                this.worker.onmessage = oldHandler; 
                resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null });
            }, 5000); 

            let best="-", ev="0.00", pv="", wdl=null;

            const list = (e) => {
                const l = e.data;
                if (l.includes(' pv ')) pv = l.split(' pv ')[1];
                if (l.includes(' wdl ')) { const m=l.match(/wdl (\d+) (\d+) (\d+)/); if(m) wdl=[parseInt(m[1]), parseInt(m[2]), parseInt(m[3])]; }
                if (l.includes('cp ')) { const m=l.match(/cp (-?\d+)/); if(m) ev=(parseInt(m[1])/100 * (fen.includes(' b ')?-1:1)).toFixed(2); }
                if (l.includes('mate ')) { const m=l.match(/mate (-?\d+)/); if(m) ev="M"+(parseInt(m[1])); }
                
                if (l.startsWith('bestmove')) {
                    clearTimeout(tId);
                    best = l.split(' ')[1];
                    this.worker.onmessage = oldHandler; 
                    if(!wdl && !ev.toString().startsWith('M')) wdl = this.estimateWDL(parseFloat(ev));
                    resolve({ eval: ev, bestMove: best, pv: pv, wdl: wdl });
                }
            };
            this.worker.onmessage = (e) => list(e);
            
            this.worker.postMessage('stop');
            this.worker.postMessage(`position fen ${fen}`);
            // Reduced depth for speed
            this.worker.postMessage('go depth 12'); 
        });
    },

    estimateWDL: function(ev) {
        const w = 1000 / (1 + Math.exp(-ev));
        const l = 1000 - w;
        return [Math.round(w), 0, Math.round(l)];
    },

    getBestMove: function(fen) {
        return new Promise(resolve => {
            if(!this.isReady) resolve(null);
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;
            const listener = (e) => {
                if(e.data.startsWith('bestmove')) {
                    const move = e.data.split(' ')[1];
                    this.worker.onmessage = oldHandler;
                    resolve(move);
                }
            };
            this.worker.onmessage = (e) => listener(e);
            this.worker.postMessage('stop');
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 12');
        });
    },
    
    analyze: function(fen) {
        if(!this.isReady) return;
        this.worker.postMessage('stop');
        this.worker.postMessage(`position fen ${fen}`);
        this.worker.postMessage('go depth 14');
        
        const listener = (e) => {
            const line = e.data;
            let cp = 0, mate = null;
            
            if(line.includes('score mate')) {
                 const m = line.match(/score mate (-?\d+)/);
                 if(m) mate = parseInt(m[1]);
            } else if(line.includes('score cp')) {
                const m = line.match(/score cp (-?\d+)/);
                if(m) cp = parseInt(m[1]);
            }

            if (line.includes(' pv ')) {
                 let activeColor = fen.split(' ')[1];
                 let evalVal = cp;
                 if(activeColor === 'b') {
                     evalVal = -cp;
                     if(mate !== null) mate = -mate;
                 }
                 // STRICT CHECK: Only update eval if the analyzed fen matches current board
                 if (Game.getActiveChess().fen().split(' ')[0] === fen.split(' ')[0]) {
                    GUI.updateEval(evalVal, mate);
                 }
            }
            if(line.startsWith('bestmove')) this.worker.removeEventListener('message', listener);
        };
        this.worker.addEventListener('message', listener);
    },
    
    playResponse: function(fen) {
         if(!this.isReady || this.isThinking) return;
         
         this.isThinking = true;
         this.worker.postMessage('stop');
         this.worker.postMessage(`position fen ${fen}`);
         this.worker.postMessage('go movetime 1000'); 
         
         // Watchdog: If engine doesn't reply in 3s, force reset
         const watchdog = setTimeout(() => {
             if(this.isThinking) {
                 log("Engine Timeout - Forcing Reset", 'warn');
                 this.stop();
                 this.isThinking = false;
             }
         }, 3000);

         const listener = (e) => {
             if(e.data.startsWith('bestmove')) {
                 clearTimeout(watchdog);
                 const best = e.data.split(' ')[1];
                 this.worker.removeEventListener('message', listener);
                 this.isThinking = false;
                 // Prevent move if game reset in background
                 if (Game.mode === 'play') {
                     Game.engineMove(best);
                 }
             }
         };
         this.worker.addEventListener('message', listener);
    },

    getTopMoves: function(fen, count) {
        return new Promise(resolve => {
            if(!this.isReady) resolve([]);
            let moves = [];
            const oldHandler = this.worker.onmessage;
            this.worker.onmessage = null;
            const listener = (e) => {
                const line = e.data;
                if(line.startsWith('info') && line.includes('multipv') && line.includes('pv')) {
                    const parts = line.split(' pv ');
                    if(parts[1]) {
                        const m = parts[1].split(' ')[0];
                        if (!moves.includes(m)) moves.push(m);
                    }
                }
                if(line.startsWith('bestmove')) {
                    this.worker.onmessage = oldHandler;
                    resolve(moves);
                }
            };
            this.worker.onmessage = (e) => listener(e);
            this.worker.postMessage('stop');
            this.worker.postMessage(`setoption name MultiPV value ${count}`);
            this.worker.postMessage(`position fen ${fen}`);
            this.worker.postMessage('go depth 10'); 
            setTimeout(() => this.worker.postMessage('setoption name MultiPV value 1'), 500); 
        });
    }
};

/**
 * TACTICAL HEAT MAP ENGINE - V2 (Defenders/Attackers)
 */
const HeatMap = {
    val: { p: 1, n: 3, b: 3, r: 5, q: 9, k: 100 },
    
    analyze: function(chess) {
        const fen = chess.fen();
        const turn = chess.turn();
        const opp = turn === 'w' ? 'b' : 'w';
        
        // Detailed attack map: Square -> List of Pieces (e.g. 'e4' -> ['n', 'q'])
        const myDefenses = this.getDetailedAttacks(chess, turn); 
        const oppAttacks = this.getDetailedAttacks(chess, opp); 

        let hanging = [];
        let pressure = [];
        let radar = []; // For Gemini

        const board = chess.board(); 
        const files = ['a','b','c','d','e','f','g','h'];

        for(let r=0; r<8; r++){
            for(let c=0; c<8; c++){
                const piece = board[r][c];
                if(piece && piece.color === turn) {
                    const sq = files[c] + (8-r);
                    const attackers = oppAttacks[sq] || [];
                    const defenders = myDefenses[sq] || [];
                    
                    const atkCount = attackers.length;
                    const defCount = defenders.length;

                    if (atkCount > 0) {
                        const atkStr = attackers.join(', ');
                        const defStr = defenders.join(', ');
                        
                        let status = "Safe";
                        if (defCount === 0) {
                            status = "HANGING";
                            hanging.push(sq);
                        } else if (atkCount > defCount) {
                            status = "OVERWHELMED";
                            pressure.push(sq);
                        } else {
                            status = "Contested";
                        }

                        // Detailed string for Gemini
                        radar.push(`${piece.type.toUpperCase()} at ${sq}: Attacked by ${atkCount} (${atkStr}), Defended by ${defCount} (${defStr}). Status: ${status}`);
                    }
                }
            }
        }
        
        return { 
            hanging: hanging, 
            pressure: pressure, 
            radar: radar 
        };
    },

    // Returns Map: Square -> ['p', 'n', 'q'...] (Types of attackers)
    getDetailedAttacks: function(chessInstance, color) {
        const temp = new Chess(chessInstance.fen());
        // Force turn to generate moves
        if (temp.turn() !== color) {
            const tokens = temp.fen().split(' ');
            tokens[1] = color;
            tokens[3] = '-'; 
            temp.load(tokens.join(' '));
        }
        
        const moves = temp.moves({ verbose: true });
        const attackMap = {};
        
        moves.forEach(m => {
            if (!attackMap[m.to]) attackMap[m.to] = [];
            // Push the piece type that is attacking
            attackMap[m.to].push(m.piece);
        });
        return attackMap;
    }
};

/**
 * GEMINI AI
 */
const Gemini = {
    comments: {}, 
    getCommentary: async function(analysisData, openingName, focus) {
        const k = getEffectiveKey();
        if (!k) { alert("Please set API Key in Settings!"); return false; }

        let logStr = `Game Context:\nOpening: ${openingName}\n\n`;
        
        analysisData.forEach((d, i) => {
            const isUserTurn = (focus === 'both' || focus === d.color);
            if (!isUserTurn) return;

            let evalText = d.eval;
            if(d.eval.toString().startsWith('M')) evalText = `Mate in ${d.eval.replace('M','')}`;

            const moveInfo = `[PLY ${i+1}] ${d.color==='w'?'White':'Black'} played ${d.san}`;
            const engineInfo = `\n   - Best Move: ${d.bestMoveSan || '?'}`;
            const engineLine = `\n   - PV (Engine Plan): ${d.pvSan || 'None'}`;
            
            const heat = d.tactics || { hanging: [], pressure: [], radar: [] };
            let tacticalText = "\n   - Tactical Status (Before Move):\n";
            if (heat.radar.length === 0) tacticalText += "     No immediate threats detected.";
            else heat.radar.forEach(line => tacticalText += `     * ${line}\n`);

            const outcome = `\n   - Result: Eval ${evalText}, Class ${d.classification}`;
            
            logStr += `${moveInfo} ${tacticalText} ${engineInfo} ${engineLine} ${outcome}\n\n`;
        });

        if (logStr.length < 50) logStr = "Game was short.";

        const prompt = `
You are a Grandmaster Chess Coach.

**YOUR DATA SOURCE:**
For every move, I have provided:
1. The Move & Engine Best Move.
2. **Tactical Radar:** This gives you a heatmap of EXACTLY who is attacking and defending each piece.
   - Example: "N at f3: Attacked by 2 (q, r), Defended by 1 (p). Status: OVERWHELMED".
3. **Principal Variation (PV):** The future moves the engine predicts.

**CRITICAL INSTRUCTIONS:**
1. **No Meta-Talk:** Do NOT mention phrases like "The Tactical Radar shows", "The data indicates", or "My sensors detect". Speak naturally, like a human coach looking at the board.
2. **Book Moves:** If a move is classified as 'Book', explain the strategic opening principle (e.g., controlling center, developing pieces). DO NOT CRITICIZE IT.
3. **Defensive Logic:** If a move defends a piece that was listed as 'HANGING' or 'OVERWHELMED', acknowledge the defense. Do NOT say the piece is ignored if the move successfully defends it.
4. **JSON ONLY:** Return *only* the JSON object.

**TASK:**
Explain the moves in the provided game log.

**JSON Format:**
{
    "12": {
        "analysis": "This pawn push is a mistake. Your Knight on f3 was overwhelmed (2 attackers vs 1 defender), and this move unpins it but loses material.",
        "pv_explanation": ["Nf3 prevents the fork", "Be2 prepares castling"] 
    }
}

**Game Log:**
${logStr}
        `;

        try {
            log("Sending rich context request to Gemini...");
            
            // Timeout Wrapper for Fetch
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout
            
            const res = await fetch(MODEL_ENDPOINT+`?key=${k}`, {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            const d = await res.json();
            if(!d.candidates || !d.candidates[0]) return false;
            const text = d.candidates[0].content.parts[0].text;
            let cleanText = text.replace(/```json/g, '').replace(/```/g, '');
            const start = cleanText.indexOf('{');
            const end = cleanText.lastIndexOf('}');
            if (start !== -1 && end !== -1) {
                cleanText = cleanText.substring(start, end + 1);
                this.comments = JSON.parse(cleanText);
                log("Gemini Analysis Complete.");
                return true;
            }
            return false;
        } catch (e) { 
            console.error("Gemini Error", e);
            log("Coach Analysis Failed: " + e.message, 'error');
            return false; 
        }
    }
};

/**
 * GAME LOGIC
 */
const Game = {
    data: [],
    
    // TWO Separate Board States
    analysisChess: new Chess(),
    playChess: new Chess(),
    
    history: [],
    index: -1,
    userColor: 'w',
    playUserColor: 'w', // Current user color in Computer Play
    playViewIndex: -1, // -1 means live. 0+ means reviewing history
    analysisData: [], 
    puzzles: [], 
    mode: 'analysis',
    selectedSquare: null, // For Tap-to-Move
    
    // STORAGE
    save: function() {
        localStorage.setItem('chess_games', JSON.stringify(this.data));
    },
    
    loadFromStorage: function() {
        const d = localStorage.getItem('chess_games');
        if(d) {
            this.data = JSON.parse(d);
            renderList();
        }
    },

    // Helper to get active instance
    getActiveChess: function() {
        return (this.mode === 'play') ? this.playChess : this.analysisChess;
    },

    cleanPGN: function(pgn) {
        if (!pgn) return "";
        let body = pgn.replace(/\[.*?\]/g, ' ').replace(/\{.*?\}/g, ' ').replace(/\(.*?\)/g, ' ').replace(/\$\d+/g, ' ');
        return body.replace(/\s+/g, ' ').trim();
    },

    load: function(id) {
        const g = this.data.find(x => x.id === id);
        if(!g) return;
        
        log(`Loading Game ID ${id}...`);
        this.analysisChess.reset();
        
        const movesOnly = this.cleanPGN(g.pgn);
        let success = this.analysisChess.load_pgn(movesOnly);
        if(!success) success = this.analysisChess.load_pgn(g.pgn);
        
        if(!success) {
            log("ERROR: PGN Parse Failed.", 'error');
            return;
        }
        
        this.history = this.analysisChess.history({ verbose: true });
        this.resetToStart();
        
        document.getElementById('gameTitle').innerText = g.opening;
        document.getElementById('scanBtn').disabled = false;
        
        this.analysisData = [];
        this.puzzles = [];
        Gemini.comments = {};
        
        GUI.renderAnalysisList();
        GUI.resetCoachDisplay();
        
        document.getElementById('puzzleBadge').classList.add('d-none');
        document.getElementById('board').classList.remove('opacity-50');

        let rawColor = (g.userColor || 'white').toLowerCase();
        this.userColor = rawColor.startsWith('b') ? 'b' : 'w';
        
        GUI.board.orientation(this.userColor === 'b' ? 'black' : 'white');
        GUI.switchTab('analysis');
        setTimeout(() => GUI.board.resize(), 100);
    },
    
    resetToStart: function() {
        this.analysisChess.reset();
        this.index = -1;
        GUI.update();
        Engine.analyze(this.analysisChess.fen());
    },
    
    move: function(from, to, prom) {
        const chess = this.getActiveChess();
        
        // If reviewing past in play mode, snap to present first
        if (this.mode === 'play' && this.playViewIndex !== -1) {
            this.playViewIndex = -1; // Reset to live
            GUI.update(); // Visually snap back
        }

        // Strict legality check handled by chess.js move() returning null on invalid move
        const move = chess.move({ from: from, to: to, promotion: prom || 'q' });
        
        if(move) {
            if (this.mode === 'analysis') {
                this.index++; 
                GUI.update();
                Engine.analyze(chess.fen());
            } 
            else if (this.mode === 'play') {
                this.playViewIndex = -1; // Ensure we are live
                GUI.update();
                if (chess.in_checkmate()) document.getElementById('checkmateOverlay').classList.remove('d-none');
                
                if (!chess.game_over()) {
                    Engine.playResponse(chess.fen());
                }
                Engine.analyze(chess.fen());
            }
            GUI.clearArrows();
            return true;
        }
        return false;
    },

    engineMove: function(bestMoveUci) {
        if (this.mode !== 'play') return;
        
        // Always apply engine move to live game state
        const from = bestMoveUci.substring(0,2);
        const to = bestMoveUci.substring(2,4);
        const prom = bestMoveUci.length > 4 ? bestMoveUci.substring(4,5) : 'q';
        
        this.playChess.move({ from: from, to: to, promotion: prom });
        
        // Only update UI if user is watching live
        if (this.playViewIndex === -1) {
             GUI.update();
        } else {
            GUI.showToast("Engine moved (hidden)", "warn");
        }
        
        if (this.playChess.in_checkmate()) document.getElementById('checkmateOverlay').classList.remove('d-none');
        Engine.analyze(this.playChess.fen());
    },
    
    nav: function(dir) {
        document.getElementById('checkmateOverlay').classList.add('d-none');
        GUI.clearArrows();
        
        if (this.mode === 'analysis') {
            if(dir === 'next' && this.index < this.history.length - 1) {
                this.index++;
                this.analysisChess.move(this.history[this.index].san);
            } else if (dir === 'prev' && this.index >= 0) {
                this.analysisChess.undo();
                this.index--;
            } else if (dir === 'first') {
                this.analysisChess.reset();
                this.index = -1;
            } else if (dir === 'last') {
                while(this.index < this.history.length - 1) {
                    this.index++;
                    this.analysisChess.move(this.history[this.index].san);
                }
            }
            GUI.update();
            Engine.analyze(this.analysisChess.fen());
        } else if (this.mode === 'play') {
            // Play Mode Navigation = Review History (Visual Only)
            const history = this.playChess.history();
            if (this.playViewIndex === -1) this.playViewIndex = history.length - 1;
            
            if (dir === 'prev') {
                if (this.playViewIndex >= -1) this.playViewIndex--; 
            } else if (dir === 'next') {
                 if (this.playViewIndex < history.length - 1) this.playViewIndex++;
                 else this.playViewIndex = -1; // Snap to live
            }
            
            // Boundary checks
            if (this.playViewIndex < -1) this.playViewIndex = -1;
            
            GUI.update();
        }
    }
};

/**
 * SCANNER - The Truth Pipeline
 */
const Scanner = {
    start: async function() {
        const btn = document.getElementById('scanBtn');
        const bar = document.getElementById('scanBar');
        const text = document.getElementById('scanText');
        const progressBox = document.getElementById('scanProgress');
        const focus = document.getElementById('analysisFocus').value;
        const navBtns = document.querySelectorAll('#verticalAnalysisControls button');

        if (!Game.history || Game.history.length === 0) {
            GUI.showToast("No moves to analyze!", "error");
            return;
        }

        // Reset and show UI
        btn.disabled = true;
        navBtns.forEach(b => b.disabled = true);
        
        // Force removal of hidden class and ensure z-index visibility
        progressBox.classList.remove('d-none');
        bar.style.width = '0%';
        bar.className = "progress-bar progress-bar-striped progress-bar-animated"; // Reset class
        
        try {
            Game.analysisData = []; 
            Game.puzzles = []; 
            
            const moves = Game.history;
            const tempChess = new Chess();
            
            for(let i=0; i<moves.length; i++) {
                // UI Breather - Allows browser to paint progress bar
                await new Promise(r => setTimeout(r, 20));

                const fenBefore = tempChess.fen();
                
                let isBook = false;
                if (i < 15) {
                    const bookResult = await this.fetchBookData(fenBefore);
                    if (bookResult) {
                        const bookMoves = bookResult.moves.map(m => m.uci);
                        const moveObj = moves[i];
                        const userUci = moveObj.from + moveObj.to + (moveObj.promotion || '');
                        if (bookMoves.includes(userUci)) isBook = true;
                    }
                }

                const tacticalSnapshot = HeatMap.analyze(tempChess);

                const preMoveResult = await Engine.runScan(fenBefore);
                let scoreBefore = this.parseEval(preMoveResult.eval);
                
                let bestMoveSan = preMoveResult.bestMove;
                let bestLineSan = "";

                if(preMoveResult.bestMove && preMoveResult.bestMove !== '-') {
                    const simGame = new Chess(fenBefore);
                    const bm = simGame.move({ from: preMoveResult.bestMove.substring(0,2), to: preMoveResult.bestMove.substring(2,4), promotion: 'q' });
                    if(bm) bestMoveSan = bm.san;
                    if(preMoveResult.pv) bestLineSan = this.uciToSan(fenBefore, preMoveResult.pv);
                }

                const moveObj = moves[i];
                const userUci = moveObj.from + moveObj.to + (moveObj.promotion || '');
                
                tempChess.move(moveObj.san);
                const fenAfter = tempChess.fen();
                
                const isMate = tempChess.in_checkmate();
                let scoreAfter = 0;
                let evAfterStr = "";

                if (isMate) {
                    scoreAfter = (moveObj.color === 'w') ? 100 : -100;
                    evAfterStr = "M0"; 
                } else {
                    const postMoveResult = await Engine.runScan(fenAfter);
                    evAfterStr = postMoveResult.eval;
                    scoreAfter = this.parseEval(postMoveResult.eval);
                }

                let evalLoss = (moveObj.color === 'w') ? scoreBefore - scoreAfter : scoreAfter - scoreBefore;
                if (moveObj.color === 'b') evalLoss = -evalLoss;
                let cls = "Neutral";
                let loss = 0;
                if (moveObj.color === 'w') loss = scoreBefore - scoreAfter;
                else loss = scoreAfter - scoreBefore;
                
                if (isBook) cls = "Book";
                else if (isMate) cls = "Best";
                else if (userUci === preMoveResult.bestMove) cls = "Best";
                else {
                    const wasWinning = (moveObj.color === 'w' ? scoreBefore > 2 : scoreBefore < -2);
                    const isWinning = (moveObj.color === 'w' ? scoreAfter > 1 : scoreAfter < -1);
                    
                    if (wasWinning && !isWinning) cls = "Missed"; // Missed Win
                    else if (loss >= 2.0) cls = "Blunder";
                    else if (loss >= 1.0) cls = "Mistake";
                    else if (loss >= 0.5) cls = "Inaccuracy";
                    else if (loss >= 0.2) cls = "Good";
                    else if (loss >= 0.05) cls = "Excellent";
                    else cls = "Best"; 
                }
                
                Game.analysisData.push({
                    san: moveObj.san, color: moveObj.color,
                    eval: evAfterStr, 
                    evalDiff: loss.toFixed(2),
                    wdl: preMoveResult.wdl,
                    bestMoveSan: bestMoveSan,
                    pvSan: bestLineSan,
                    classification: cls,
                    fenBefore: fenBefore,
                    isMate: isMate,
                    tactics: tacticalSnapshot
                });
                
                if ((cls === 'Blunder' || cls === 'Mistake' || cls === 'Missed') && moveObj.color === Game.userColor) {
                    Game.puzzles.push({ fen: fenBefore, color: moveObj.color, solution: preMoveResult.bestMove });
                }

                bar.style.width = Math.round(((i+1)/moves.length)*50) + "%"; 
                text.innerText = `Analyzing: ${i+1}/${moves.length}`;
            }

            if (Game.puzzles.length > 0) {
                document.getElementById('puzzleBadge').innerText = Game.puzzles.length;
                document.getElementById('puzzleBadge').classList.remove('d-none');
            }

            text.innerText = "Consulting Grandmaster Coach...";
            document.getElementById('coachDisplay').innerHTML = '<div class="text-center p-3 text-muted"><i class="fa-solid fa-brain fa-spin me-2"></i> Analyzing threats & variations...</div>';
            bar.className = "progress-bar bg-success progress-bar-striped progress-bar-animated";
            
            await Gemini.getCommentary(Game.analysisData, "Custom Game", focus);
            
            bar.style.width = "100%";
            GUI.renderAnalysisList();

            // Auto Play First Move on Finish
            Game.nav('first'); // Reset
            setTimeout(() => { Game.nav('next'); }, 600);

            // Toast Notification
            GUI.showToast("Analysis Complete", "success");

        } catch(err) {
            console.error(err);
            GUI.showToast("Analysis Failed. Check logs.", "error");
        } finally {
            // ALWAYS re-enable buttons, even if crashed
            setTimeout(() => { 
                progressBox.classList.add('d-none'); 
                btn.disabled = false;
                navBtns.forEach(b => b.disabled = false); 
            }, 1000);
        }
    },

    fetchBookData: async function(fen) {
        try { 
            // 2 Second Timeout for book fetch to prevent hanging
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000);
            
            const res = await fetch(`https://explorer.lichess.ovh/masters?fen=${fen}`, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if(res.ok) return await res.json();
        } catch(e){ return null; }
        return null;
    },
    parseEval: function(str) {
        if (typeof str === 'string' && str.startsWith('M')) {
             const moves = parseInt(str.replace('M', ''));
             if (moves === 0) return 100; 
             return moves > 0 ? 10 : -10; 
        }
        return parseFloat(str);
    },
    uciToSan: function(fen, pv) {
        if(!pv) return "";
        const t = new Chess(fen);
        let s = "";
        const mvs = pv.split(' ');
        for(let m of mvs) {
            if(!m) continue;
            const mo = t.move({from:m.substring(0,2), to:m.substring(2,4), promotion: m.length>4?m.substring(4,5):undefined});
            if(mo) s += mo.san + " "; else break;
        }
        return s.trim();
    }
};

/**
 * PUZZLE MANAGER
 */
const PuzzleManager = {
    currentIdx: 0,
    activePuzzle: null,
    vsEngine: false,

    init: function() { this.vsEngine = false; },

    toggleEngineMode: function() {
        this.vsEngine = document.getElementById('puzzleVsEngine').checked;
        const feedback = document.getElementById('puzzleFeedback');
        if (this.vsEngine) {
            feedback.innerHTML = '<span class="text-primary"><i class="fa-solid fa-robot"></i> Engine Mode: Play any move.</span>';
        } else {
            feedback.innerHTML = '';
            if(this.activePuzzle) {
                Game.analysisChess.load(this.activePuzzle.fen); // Use analysisChess as temp for puzzle board display
                GUI.board.position(this.activePuzzle.fen);
            }
        }
    },

    loadPuzzles: function() {
        if (Game.puzzles.length === 0) {
            document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted">No puzzles generated. Please scan a game first.</span>`;
            document.getElementById('board').classList.add('opacity-50');
            return;
        }
        document.getElementById('board').classList.remove('opacity-50');
        document.getElementById('puzzleEngineContainer').classList.remove('d-none');
        this.currentIdx = 0;
        this.showPuzzle(0);
    },

    showPuzzle: function(idx) {
        if (idx >= Game.puzzles.length) {
            document.getElementById('puzzleFeedback').innerHTML = `<span class="text-primary fw-bold">Training Complete!</span>`;
            return;
        }
        
        this.currentIdx = idx;
        this.activePuzzle = Game.puzzles[idx];
        
        Game.analysisChess.load(this.activePuzzle.fen);
        GUI.board.position(this.activePuzzle.fen);
        GUI.board.orientation(this.activePuzzle.color === 'w' ? 'white' : 'black');
        GUI.clearArrows();
        GUI.updateMaterial(); 
        
        document.getElementById('puzzleCountBadge').innerText = `Puzzle ${idx + 1}/${Game.puzzles.length}`;
        document.getElementById('puzzleFeedback').innerHTML = "";
    },

    handleDrop: async function(source, target) {
        if (this.vsEngine) {
            const move = Game.analysisChess.move({ from: source, to: target, promotion: 'q' });
            if (move) {
                GUI.update();
                Engine.analyze(Game.analysisChess.fen());
                if (!Game.analysisChess.game_over()) {
                      setTimeout(async () => {
                        const best = await Engine.getBestMove(Game.analysisChess.fen());
                        if (best) {
                            Game.analysisChess.move({ from: best.substring(0,2), to: best.substring(2,4), promotion: 'q' });
                            GUI.update();
                            Engine.analyze(Game.analysisChess.fen());
                        }
                    }, 500);
                }
                return undefined;
            }
            return 'snapback';
        }

        const valid = await this.validateMove(source, target);
        if (valid) {
            Game.analysisChess.move({ from: source, to: target, promotion: 'q' });
            GUI.updateMaterial();
            return undefined;
        } else {
            return 'snapback';
        }
    },

    validateMove: async function(source, target) {
        if (!this.activePuzzle) return false;
        
        const userUci = source + target; 
        const primarySol = this.activePuzzle.solution;
        
        if (primarySol.indexOf(userUci) === 0) {
            this.onSuccess();
            return true;
        }
        
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-muted"><i class="fa-solid fa-spinner fa-spin"></i> Checking alternative...</span>`;
        const topMoves = await Engine.getTopMoves(this.activePuzzle.fen, 3);
        const isGood = topMoves.some(m => m.indexOf(userUci) === 0);
        
        if (isGood) {
            this.onSuccess();
            return true;
        } else {
            this.onFail();
            return false;
        }
    },

    onSuccess: function() {
        document.getElementById('board').classList.add('puzzle-success');
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-correct"><i class="fa-solid fa-check"></i> Correct!</span>`;
        setTimeout(() => document.getElementById('board').classList.remove('puzzle-success'), 500);
    },

    onFail: function() {
        document.getElementById('board').classList.add('puzzle-fail');
        document.getElementById('puzzleFeedback').innerHTML = `<span class="text-incorrect"><i class="fa-solid fa-xmark"></i> Incorrect. Try again.</span>`;
        setTimeout(() => {
            document.getElementById('board').classList.remove('puzzle-fail');
            document.getElementById('puzzleFeedback').innerHTML = "";
            if(this.activePuzzle && !this.vsEngine) {
                Game.analysisChess.load(this.activePuzzle.fen);
                GUI.board.position(this.activePuzzle.fen);
            }
        }, 1000); 
    },

    next: function() {
        if (this.currentIdx < Game.puzzles.length - 1) this.showPuzzle(this.currentIdx + 1);
    },
    
    prev: function() {
        if (this.currentIdx > 0) this.showPuzzle(this.currentIdx - 1);
    },
    
    skip: function() {
        if (this.currentIdx < Game.puzzles.length - 1) this.showPuzzle(this.currentIdx + 1);
    }
};

/**
 * GUI & INTERACTION
 */
const GUI = {
    board: null,
    settingsModal: null,
    hintState: 0, 
    showEvalInPlay: true,
    
    init: function() {
        this.board = Chessboard('board', {
            draggable: true,
            position: 'start',
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
            onDragStart: (src, p) => {
                // Drag start cleans up tap selection
                Game.selectedSquare = null;
                $('.square-55d63').removeClass('highlight-selected');

                // READ-ONLY ANALYSIS
                if (Game.mode === 'analysis') return false; 
                
                const chess = Game.getActiveChess();
                const turnColor = chess.turn(); 
                const pieceColor = p.charAt(0); 
                
                // Computer Play Mode: Strict Side & Turn Checking
                if (Game.mode === 'play') {
                    // Rule 1: Must be user's color to pick up
                    if (pieceColor !== Game.playUserColor) return false;
                    
                    // Rule 2: Must be user's TURN to pick up
                    if (chess.turn() !== Game.playUserColor) return false;
                    
                    // Rule 3: Game must not be over
                    if (chess.game_over()) return false;
                    
                    // Rule 4: Can't move if viewing history
                    if (Game.playViewIndex !== -1) {
                        GUI.showToast("Return to live game to move", "warn");
                        return false;
                    }
                }

                if (turnColor !== pieceColor) return false;
                return true;
            },
            onDrop: async (src, tgt) => {
                if (src === tgt) return;
                
                if (Game.mode === 'puzzles') {
                    return await PuzzleManager.handleDrop(src, tgt);
                } else {
                    const res = Game.move(src, tgt);
                    return res ? undefined : 'snapback';
                }
            }
        });

        // TAP TO MOVE HANDLER
        $('#board').on('click', '.square-55d63', function(e) {
            e.preventDefault();
            const square = $(this).attr('data-square');
            GUI.handleSquareClick(square);
        });

        window.addEventListener('resize', () => {
             this.board.resize();
             if (window.innerWidth <= 768) document.getElementById('sidebar').classList.add('collapsed');
        });
        
        Engine.init();
        PuzzleManager.init();
        this.settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
        
        const k = localStorage.getItem('gemini_api_key');
        if(k) document.getElementById('apiKeyInput').value = k;
        
        this.showEvalInPlay = document.getElementById('showEvalToggle').checked;
        Game.loadFromStorage();
        this.updateEloLabel(5);
        
        // Mobile Init
        if (window.innerWidth <= 768) document.getElementById('sidebar').classList.add('collapsed');
    },

    handleSquareClick: function(square) {
        if (Game.mode === 'analysis') return; // Read-only

        const chess = Game.getActiveChess();
        const turn = chess.turn();
        const piece = chess.get(square);

        // State 1: Select Piece
        if (!Game.selectedSquare) {
            if (piece && piece.color === turn) {
                // Strict check for Play mode
                if (Game.mode === 'play') {
                     if (piece.color !== Game.playUserColor) return;
                     if (chess.turn() !== Game.playUserColor) return; // Strict turn check
                     if (Game.playViewIndex !== -1) {
                         GUI.showToast("Return to live game to move", "warn");
                         return;
                     }
                }
                
                Game.selectedSquare = square;
                $('.square-55d63').removeClass('highlight-selected');
                $('.square-' + square).addClass('highlight-selected');
            }
            return;
        }

        // State 2: Move or Reselect
        const source = Game.selectedSquare;
        
        // If clicked same square, deselect
        if (source === square) {
            Game.selectedSquare = null;
            $('.square-55d63').removeClass('highlight-selected');
            return;
        }

        // If clicked own piece, switch selection
        if (piece && piece.color === turn) {
             // Strict check for Play mode
             if (Game.mode === 'play' && piece.color !== Game.playUserColor) {
                 // Trying to capture own piece? Invalid.
             } else {
                 Game.selectedSquare = square;
                 $('.square-55d63').removeClass('highlight-selected');
                 $('.square-' + square).addClass('highlight-selected');
                 return;
             }
        }

        // Attempt Move
        if (Game.mode === 'puzzles') {
             PuzzleManager.handleDrop(source, square).then(res => {
                 if (res === 'snapback') {
                     // Invalid puzzle move visually, but logic handled in manager
                 } else {
                     // Valid
                     GUI.board.position(Game.analysisChess.fen());
                 }
             });
        } else {
            const success = Game.move(source, square);
            if (!success) {
                // Invalid move
                Game.selectedSquare = null;
                $('.square-55d63').removeClass('highlight-selected');
            } else {
                // Valid move
                Game.selectedSquare = null;
                $('.square-55d63').removeClass('highlight-selected');
            }
        }
    },
    
    showToast: function(message, type = 'success') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `custom-toast ${type}`;
        
        let icon = type === 'success' ? '<i class="fa-solid fa-circle-check fa-lg text-success"></i>' : '<i class="fa-solid fa-triangle-exclamation fa-lg text-warning"></i>';
        
        toast.innerHTML = `${icon} <span>${message}</span>`;
        container.appendChild(toast);
        
        // Animate In
        setTimeout(() => toast.classList.add('show'), 100);
        
        // Animate Out & Remove
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    },

    updateEloLabel: function(val) {
        const elo = 800 + (val * 120);
        document.getElementById('eloLabel').innerText = `ELO: ~${elo}`;
    },

    switchTab: function(mode) {
        Game.mode = mode;
        Engine.stop();
        
        // RESET EVAL BAR IMMEDIATELY
        this.updateEval(0, null); // Visual reset
        document.getElementById('wdlValue').innerText = "Win: 50%"; 

        document.getElementById('board').classList.remove('opacity-50');
        document.querySelectorAll('.mode-tab').forEach(el => el.classList.remove('active'));
        
        if (mode === 'analysis') document.getElementById('tab-analysis').classList.add('active');
        else if (mode === 'puzzles') document.getElementById('tab-puzzles').classList.add('active');
        else document.getElementById('tab-play').classList.add('active');
        
        this.clearArrows();
        this.resetHint();

        const analysisIds = ['analysisControls', 'analysisPanel', 'scanBtn', 'verticalAnalysisControls'];
        const puzzleIds = ['puzzleControls', 'puzzleStatusHeader', 'puzzleFeedback', 'puzzleEngineContainer'];
        const playIds = ['playControls'];

        const hideAll = (ids) => ids.forEach(id => document.getElementById(id)?.classList.add('d-none'));
        const showAll = (ids) => ids.forEach(id => document.getElementById(id)?.classList.remove('d-none'));
        
        hideAll(analysisIds); hideAll(puzzleIds); hideAll(playIds);
        document.getElementById('analysisPanel').classList.add('hidden'); 
        
        // Header Visiblity toggle
        const header = document.getElementById('boardHeaderContainer');

        if (mode === 'analysis') {
            header.classList.add('d-none'); // Remove dead space
            showAll(['analysisPanel', 'scanBtn', 'verticalAnalysisControls']); // Show specific analysis items
            document.getElementById('analysisPanel').classList.remove('hidden');
            document.getElementById('analysisListContainer').classList.add('analysis-mode-hidden'); // Hide list
            
            Game.analysisChess.reset();
            for(let i=0; i<=Game.index; i++) {
                 if(Game.history[i]) Game.analysisChess.move(Game.history[i].san);
            }
            this.board.position(Game.analysisChess.fen());
            this.update(); 
            this.board.orientation(Game.userColor === 'b' ? 'black' : 'white');
            document.getElementById('gameTitle').innerText = "Game Analysis";
        } 
        else if (mode === 'puzzles') {
            header.classList.remove('d-none'); 
            showAll(puzzleIds);
            PuzzleManager.loadPuzzles();
             document.getElementById('gameTitle').innerText = "Tactical Puzzles";
        }
        else if (mode === 'play') {
            header.classList.remove('d-none');
            showAll(playIds);
            this.board.position(Game.playChess.fen());
            this.update(); 
            this.board.orientation(Game.playUserColor === 'w' ? 'white' : 'black');
            document.getElementById('gameTitle').innerText = "Vs Stockfish";
        }
        this.updateMaterial();
        setTimeout(() => this.board.resize(), 100);
    },
    
    toggleSettings: function() { this.settingsModal.show(); },
    toggleLogs: function(show) { document.getElementById('logPanel').classList.toggle('hidden', !show); },
    toggleEvalBar: function(show) { 
        this.showEvalInPlay = show;
        this.updateEvalDisplayVisibility();
    },

    updateEvalDisplayVisibility: function() {
        const container = document.getElementById('boardCard');
        if (Game.mode === 'play' && !this.showEvalInPlay) {
            container.classList.add('play-mode-blind');
        } else {
            container.classList.remove('play-mode-blind');
        }
    },

    toggleSidebar: function() {
        document.getElementById('sidebar').classList.toggle('collapsed');
        setTimeout(() => this.board.resize(), 300);
    },

    toggleFullscreen: function() {
        document.getElementById('boardCard').classList.toggle('fullscreen-mode');
        setTimeout(() => this.board.resize(), 100);
    },

    // Play Mode Features
    flip: function(mode) {
        if (mode === 'play') {
            // Visual Flip & Logic Flip
            Game.playUserColor = Game.playUserColor === 'w' ? 'b' : 'w';
            this.board.orientation(Game.playUserColor === 'w' ? 'white' : 'black');
            GUI.clearArrows();
            
            // If flipping makes it the engine's turn to move (e.g., flipping to Black when White has just moved)
            if (Game.playChess.turn() !== Game.playUserColor && !Game.playChess.game_over()) {
                // IMPORTANT: Ensure engine moves if it's supposed to
                Engine.playResponse(Game.playChess.fen());
            }
        } else {
            // Visual flip only for analysis
            this.board.flip();
            GUI.clearArrows();
        }
    },

    resetGame: function() {
        if(confirm("Start new game?")) {
            Game.playChess.reset();
            Game.playUserColor = 'w';
            Game.playViewIndex = -1;
            this.board.orientation('white');
            document.getElementById('checkmateOverlay').classList.add('d-none');
            GUI.update();
            Engine.analyze(Game.playChess.fen());
        }
    },

    undoPlayMove: function() {
        Game.playChess.undo(); 
        Game.playChess.undo(); 
        Game.playViewIndex = -1; // Snap to live
        GUI.update();
        Engine.analyze(Game.playChess.fen());
    },

    update: function() {
        this.resetHint();
        this.clearArrows();
        this.updateMaterial();
        this.updateEvalDisplayVisibility(); 
        
        if (Game.mode === 'puzzles') return;
        
        if (Game.mode === 'play') {
             // Handle Review vs Live View
             if (Game.playViewIndex === -1) {
                 this.board.position(Game.playChess.fen());
             } else {
                 // Reconstruct state from history
                 const history = Game.playChess.history();
                 const temp = new Chess();
                 for(let i=0; i<=Game.playViewIndex; i++) temp.move(history[i]);
                 this.board.position(temp.fen());
                 
                 // Add visual indicator that we are in review mode
                 this.showToast("Viewing History - Move piece to reset", "warn");
             }
             
             // Eval only for live
             if(Game.playViewIndex === -1) Engine.analyze(Game.playChess.fen());
             return;
        }

        // ANALYSIS UPDATE
        const chess = Game.getActiveChess();
        this.board.position(chess.fen());
        const moveIdx = Game.index; 
        const ply = moveIdx + 1; 

        const display = document.getElementById('coachDisplay');
        let commentData = Gemini.comments[ply.toString()];
        const analysisItem = Game.analysisData[moveIdx];
        
        display.className = "coach-display"; 
        if(analysisItem) display.classList.add(analysisItem.classification);

        if (commentData) {
            let html = `<div><strong>${analysisItem.classification}</strong>. ${marked.parse(commentData.analysis)}</div>`;
            if (commentData.pv_explanation && commentData.pv_explanation.length > 0) {
                html += `<div class="mt-2 text-muted small border-top pt-2"><strong><i class="fa-solid fa-list-ol"></i> Plan:</strong><ul>`;
                commentData.pv_explanation.forEach(line => html += `<li>${line}</li>`);
                html += `</ul></div>`;
            }
            display.innerHTML = html;
        } else if (analysisItem) {
             display.innerHTML = `<div><strong>${analysisItem.classification}</strong>. ${analysisItem.bestMoveSan ? `Missed <span class="badge bg-success">${analysisItem.bestMoveSan}</span>.` : ''}</div>
             <div class="mt-3 text-muted small"><i class="fa-solid fa-microchip"></i> Engine Best: ${analysisItem.bestMoveSan}</div>
             `;
        }
    },
    
    updateMaterial: function() {
        const chess = Game.mode === 'puzzles' ? Game.analysisChess : Game.getActiveChess();
        const board = chess.board();
        
        const fullSet = { p:8, n:2, b:2, r:2, q:1, k:1 };
        let currentCounts = { w: {p:0,n:0,b:0,r:0,q:0,k:0}, b: {p:0,n:0,b:0,r:0,q:0,k:0} };
        
        for(let r=0; r<8; r++){
            for(let c=0; c<8; c++){
                const p = board[r][c];
                if(p) currentCounts[p.color][p.type]++;
            }
        }
        
        const icons = { p: '', n: '', b: '', r: '', q: '', k: '' }; 
        const getGraveyard = (colorOfPiecesCaptured) => {
            let s = "";
            ['q','r','b','n','p'].forEach(type => {
                let capturedCount = fullSet[type] - currentCounts[colorOfPiecesCaptured][type];
                if(capturedCount > 0) {
                    for(let i=0; i<capturedCount; i++) s += `<span class="ms-1">${icons[type]}</span>`;
                }
            });
            return s;
        }
        
        document.getElementById('matWhite').innerHTML = getGraveyard('b');
        document.getElementById('matBlack').innerHTML = getGraveyard('w');
    },

    resetCoachDisplay: function() {
        document.getElementById('coachDisplay').innerHTML = `<div class="text-center text-muted" style="margin-top:20px"><i class="fa-solid fa-chess"></i><br>Ready.</div>`;
    },
    
    updateEval: function(cp, mate) {
        let valText = "0.00";
        let pct = 50;
        let winPct = 50;
        
        if (mate !== null) {
            valText = `M${Math.abs(mate)}`;
            pct = mate > 0 ? 100 : 0;
            winPct = mate > 0 ? 100 : 0;
        } else {
            valText = (cp / 100).toFixed(2);
            if(cp > 0) valText = "+" + valText;
            let val = Math.max(-500, Math.min(500, cp));
            pct = 50 + (val / 10);
            winPct = 50 + (50 * (2 / (1 + Math.exp(-0.004 * cp)) - 1));
        }
        
        document.getElementById('evalValue').innerText = valText;
        document.getElementById('evalFill').style.width = pct + '%';
        document.getElementById('wdlValue').innerText = `Win: ${Math.round(winPct)}%`;
    },

    renderAnalysisList: function() {
        const list = document.getElementById('analysisList');
        list.innerHTML = "";
        Game.analysisData.forEach((d, i) => {
            const div = document.createElement('div');
            div.className = 'log-entry';
            div.id = `log-${i}`;
            div.onclick = () => {
                Game.analysisChess.reset();
                for(let k=0; k<=i; k++) Game.analysisChess.move(Game.history[k].san);
                Game.index = i;
                GUI.update();
                Engine.analyze(Game.analysisChess.fen());
                GUI.clearArrows();
            };
            const moveNum = Math.ceil((i + 1) / 2) + (d.color === 'w' ? '.' : '...');
            
            div.innerHTML = `
                <div class="d-flex align-items-center">
                    <span class="text-muted small me-2" style="width:25px">${moveNum}</span> 
                    <strong>${d.san}</strong>
                </div>
                <div class="d-flex align-items-center gap-1">
                    <span class="small text-muted">${d.eval}</span>
                    <span class="move-class class-${d.classification}">${d.classification}</span>
                </div>`;
            list.appendChild(div);
        });
    },
    
    hint: async function() {
        const fen = Game.getActiveChess().fen();
        const best = await Engine.getBestMove(fen);
        if(!best) return;
        const from = best.substring(0,2);
        const to = best.substring(2,4);

        if (this.hintState === 0) {
            $('.square-55d63').removeClass('highlight-hint');
            $('.square-' + from).addClass('highlight-hint');
            this.hintState = 1;
        } else {
            this.drawArrow(from, to, '#22c55e');
            this.hintState = 0;
        }
    },
    
    showBestMove: async function() {
        const fen = Game.getActiveChess().fen();
        const best = await Engine.getBestMove(fen);
        if(!best) return;
        const from = best.substring(0,2);
        const to = best.substring(2,4);
        
        this.clearArrows();
        this.drawArrow(from, to, '#22c55e');
        
        // Highlight square temporarily
        $('.square-' + from).addClass('highlight-hint');
        setTimeout(() => $('.square-' + from).removeClass('highlight-hint'), 1500);
    },
    
    resetHint: function() {
        this.hintState = 0;
        $('.square-55d63').removeClass('highlight-hint');
    },
    
    drawArrow: function(from, to, color) {
        const $board = $('#board');
        const boardWidth = $board.width();
        const sqSize = boardWidth / 8;
        const orientation = this.board.orientation();
        const cols = 'abcdefgh';
        const rows = '87654321';
        const getCoords = (sq) => {
            let c = cols.indexOf(sq[0]);
            let r = rows.indexOf(sq[1]);
            if (orientation === 'black') { c = 7 - c; r = 7 - r; }
            return { x: c * sqSize + sqSize/2, y: r * sqSize + sqSize/2 };
        }
        const start = getCoords(from);
        const end = getCoords(to);
        const svg = document.getElementById('arrowOverlay');
        const id = `arrow-${from}-${to}`;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', start.x);
        line.setAttribute('y1', start.y);
        line.setAttribute('x2', end.x);
        line.setAttribute('y2', end.y);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', sqSize * 0.15);
        line.setAttribute('opacity', '0.7');
        line.setAttribute('marker-end', `url(#head-${id})`);
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', `head-${id}`);
        marker.setAttribute('markerWidth', '4');
        marker.setAttribute('markerHeight', '4');
        marker.setAttribute('refX', '2');
        marker.setAttribute('refY', '2');
        marker.setAttribute('orient', 'auto');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M0,0 L4,2 L0,4 Z');
        path.setAttribute('fill', color);
        marker.appendChild(path);
        defs.appendChild(marker);
        svg.appendChild(defs);
        svg.appendChild(line);
    },
    
    clearArrows: function() {
        const svg = document.getElementById('arrowOverlay');
        while(svg.lastChild) svg.removeChild(svg.lastChild);
    },
    
    next: () => Game.nav('next'), prev: () => Game.nav('prev'), first: () => Game.nav('first'), last: () => Game.nav('last'),
    undo: function() { Game.analysisChess.undo(); if(Game.index >= 0) Game.index--; this.update(); Engine.analyze(Game.analysisChess.fen()); GUI.clearArrows(); },
    
    copyPGN: function() {
        const pgn = Game.getActiveChess().pgn();
        const ta = document.createElement('textarea');
        ta.value = pgn;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("PGN Copied", "success");
    },
    copyAnalysis: function() {
        if (!Game.analysisData || Game.analysisData.length === 0) { alert("No analysis available."); return; }
        let report = `Game Analysis\n\n`;
        Game.analysisData.forEach((d, i) => {
            report += `${i+1}. ${d.san} [${d.classification}] ${d.eval}\n`;
            if(Gemini.comments[i+1]) report += `Coach: ${Gemini.comments[i+1].analysis}\n`;
        });
        const ta = document.createElement('textarea');
        ta.value = report;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("Analysis Copied", "success");
    },
    copyLogs: function() {
        const txt = window.sys_logs ? window.sys_logs.join('\n') : "No logs.";
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        GUI.showToast("System Logs Copied", "success");
    }
};

function importManualPGN() {
    const pgn = document.getElementById('pgnText').value;
    if(!pgn) return;
    const newGame = { id: Date.now(), date: '-', opening: "Custom PGN", result: '?', accuracy: 0, pgn: pgn, oppRating: '?', userColor: 'white' };
    Game.data.unshift(newGame);
    Game.save();
    renderList();
    document.getElementById('pgnModal').style.display='none';
    document.getElementById('pgnModal').classList.remove('show');
    Game.load(newGame.id);
}
document.getElementById('csvInput').onchange = (e) => { if(e.target.files.length) parseFile(e.target.files[0]); };
function parseFile(file) {
    Papa.parse(file, { header: true, skipEmptyLines: true, complete: (res) => {
        const newData = res.data.map((r, i) => ({
            id: i, date: r.date || '-', opening: r.opening || 'Unknown',
            result: r.result || '-', accuracy: parseFloat(r.userAccuracy) || 0,
            pgn: r.pgn || "", oppRating: parseInt(r.opponentRating) || 0,
            userColor: (r.userColor || 'white').toLowerCase()
        }));
        Game.data = [...newData, ...Game.data];
        Game.save();
        renderList();
    }});
}
function renderList() {
    const list = document.getElementById('gameList'); list.innerHTML = "";
    let arr = [...Game.data];
    const sort = document.getElementById('sortSelect').value;
    
    if(sort === 'recent') arr.sort((a,b) => b.id - a.id);
    else if(sort === 'oldest') arr.sort((a,b) => a.id - b.id);
    else if(sort === 'acc_high') arr.sort((a,b) => b.accuracy - a.accuracy);
    else if(sort === 'acc_low') arr.sort((a,b) => a.accuracy - b.accuracy);
    else if(sort === 'elo_high') arr.sort((a,b) => b.oppRating - a.oppRating);
    else if(sort === 'elo_low') arr.sort((a,b) => a.oppRating - b.oppRating);

    arr.forEach(g => {
        const div = document.createElement('div'); div.className = "game-item"; div.id = "g-" + g.id;
        div.innerHTML = `<div class="d-flex justify-content-between fw-bold"><span class="text-truncate" style="max-width:180px">${g.opening}</span><span class="${g.result==='win'?'text-success':(g.result==='loss'?'text-danger':'text-muted')}">${g.result}</span></div><div class="game-meta">Acc: ${g.accuracy}%  Vs ${g.oppRating}</div>`;
        div.onclick = () => Game.load(g.id); list.appendChild(div);
    });
}
window.onload = function() { 
    GUI.init();
    GUI.switchTab('analysis');
};
</script>
</body>
</html>
